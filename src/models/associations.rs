// Autogenerated by Thrift Compiler (0.22.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

//
// Friendship
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Friendship {
  pub created_time: i64,
  pub status: String,
  pub relationship_type: Option<String>,
  pub mutual_friends_count: Option<i64>,
}

impl Friendship {
  pub fn new<F3, F4>(created_time: i64, status: String, relationship_type: F3, mutual_friends_count: F4) -> Friendship where F3: Into<Option<String>>, F4: Into<Option<i64>> {
    Friendship {
      created_time,
      status,
      relationship_type: relationship_type.into(),
      mutual_friends_count: mutual_friends_count.into(),
    }
  }
}

impl TSerializable for Friendship {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Friendship> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Friendship.created_time", &f_1)?;
    verify_required_field_exists("Friendship.status", &f_2)?;
    let ret = Friendship {
      created_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      status: f_2.expect("auto-generated code should have checked for presence of required fields"),
      relationship_type: f_3,
      mutual_friends_count: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friendship");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 1))?;
    o_prot.write_i64(self.created_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::String, 2))?;
    o_prot.write_string(&self.status)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.relationship_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("relationship_type", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.mutual_friends_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("mutual_friends_count", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Follow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Follow {
  pub created_time: i64,
  pub notifications_enabled: bool,
  pub follow_type: Option<String>,
}

impl Follow {
  pub fn new<F3>(created_time: i64, notifications_enabled: bool, follow_type: F3) -> Follow where F3: Into<Option<String>> {
    Follow {
      created_time,
      notifications_enabled,
      follow_type: follow_type.into(),
    }
  }
}

impl TSerializable for Follow {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Follow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Follow.created_time", &f_1)?;
    verify_required_field_exists("Follow.notifications_enabled", &f_2)?;
    let ret = Follow {
      created_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notifications_enabled: f_2.expect("auto-generated code should have checked for presence of required fields"),
      follow_type: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Follow");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 1))?;
    o_prot.write_i64(self.created_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notifications_enabled", TType::Bool, 2))?;
    o_prot.write_bool(self.notifications_enabled)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.follow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("follow_type", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Like
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Like {
  pub created_time: i64,
  pub reaction_type: String,
  pub source: Option<String>,
}

impl Like {
  pub fn new<F3>(created_time: i64, reaction_type: String, source: F3) -> Like where F3: Into<Option<String>> {
    Like {
      created_time,
      reaction_type,
      source: source.into(),
    }
  }
}

impl TSerializable for Like {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Like> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Like.created_time", &f_1)?;
    verify_required_field_exists("Like.reaction_type", &f_2)?;
    let ret = Like {
      created_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      reaction_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      source: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Like");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 1))?;
    o_prot.write_i64(self.created_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reaction_type", TType::String, 2))?;
    o_prot.write_string(&self.reaction_type)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.source {
      o_prot.write_field_begin(&TFieldIdentifier::new("source", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Membership
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Membership {
  pub joined_time: i64,
  pub role: String,
  pub status: String,
  pub invited_by_user_id: Option<i64>,
}

impl Membership {
  pub fn new<F4>(joined_time: i64, role: String, status: String, invited_by_user_id: F4) -> Membership where F4: Into<Option<i64>> {
    Membership {
      joined_time,
      role,
      status,
      invited_by_user_id: invited_by_user_id.into(),
    }
  }
}

impl TSerializable for Membership {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Membership> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Membership.joined_time", &f_1)?;
    verify_required_field_exists("Membership.role", &f_2)?;
    verify_required_field_exists("Membership.status", &f_3)?;
    let ret = Membership {
      joined_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      role: f_2.expect("auto-generated code should have checked for presence of required fields"),
      status: f_3.expect("auto-generated code should have checked for presence of required fields"),
      invited_by_user_id: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Membership");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("joined_time", TType::I64, 1))?;
    o_prot.write_i64(self.joined_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::String, 2))?;
    o_prot.write_string(&self.role)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::String, 3))?;
    o_prot.write_string(&self.status)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.invited_by_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("invited_by_user_id", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PostAuthor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PostAuthor {
  pub created_time: i64,
  pub post_source: Option<String>,
}

impl PostAuthor {
  pub fn new<F2>(created_time: i64, post_source: F2) -> PostAuthor where F2: Into<Option<String>> {
    PostAuthor {
      created_time,
      post_source: post_source.into(),
    }
  }
}

impl TSerializable for PostAuthor {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PostAuthor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PostAuthor.created_time", &f_1)?;
    let ret = PostAuthor {
      created_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      post_source: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PostAuthor");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 1))?;
    o_prot.write_i64(self.created_time)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.post_source {
      o_prot.write_field_begin(&TFieldIdentifier::new("post_source", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CommentAuthor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CommentAuthor {
  pub created_time: i64,
  pub is_edited: Option<bool>,
}

impl CommentAuthor {
  pub fn new<F2>(created_time: i64, is_edited: F2) -> CommentAuthor where F2: Into<Option<bool>> {
    CommentAuthor {
      created_time,
      is_edited: is_edited.into(),
    }
  }
}

impl TSerializable for CommentAuthor {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CommentAuthor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CommentAuthor.created_time", &f_1)?;
    let ret = CommentAuthor {
      created_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      is_edited: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CommentAuthor");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 1))?;
    o_prot.write_i64(self.created_time)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_edited {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_edited", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}


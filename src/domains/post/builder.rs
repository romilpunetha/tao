// Generated Builder pattern implementation for EntPost
// Generated by TAO Ent Framework - DO NOT EDIT
// Regenerate with: cargo run --bin entc generate

use crate::ent_framework::Entity;
use crate::infrastructure::tao::{current_time_millis, Tao};
use crate::infrastructure::tao_core::TaoOperations;
use crate::error::AppResult;
use super::entity::EntPost;
use thrift::protocol::TSerializable;
use thrift::protocol::TCompactOutputProtocol; // Added for serialization
use std::io::Cursor; // Added for serialization

#[derive(Debug, Default)]
pub struct EntPostBuilder {
    author_id: Option<i64>,
    content: Option<String>,
    media_url: Option<String>,
    created_time: Option<i64>,
    updated_time: Option<i64>,
    post_type: Option<String>,
    visibility: Option<String>,
    like_count: Option<i32>,
    comment_count: Option<i32>,
    share_count: Option<i32>,
    tags: Option<String>,
    mentions: Option<String>,
}

impl EntPostBuilder {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn author_id(mut self, author_id: i64) -> Self {
        self.author_id = Some(author_id);
        self
    }

    pub fn content(mut self, content: String) -> Self {
        self.content = Some(content);
        self
    }

    pub fn media_url(mut self, media_url: String) -> Self {
        self.media_url = Some(media_url);
        self
    }

    pub fn created_time(mut self, created_time: i64) -> Self {
        self.created_time = Some(created_time);
        self
    }

    pub fn updated_time(mut self, updated_time: i64) -> Self {
        self.updated_time = Some(updated_time);
        self
    }

    pub fn post_type(mut self, post_type: String) -> Self {
        self.post_type = Some(post_type);
        self
    }

    pub fn visibility(mut self, visibility: String) -> Self {
        self.visibility = Some(visibility);
        self
    }

    pub fn like_count(mut self, like_count: i32) -> Self {
        self.like_count = Some(like_count);
        self
    }

    pub fn comment_count(mut self, comment_count: i32) -> Self {
        self.comment_count = Some(comment_count);
        self
    }

    pub fn share_count(mut self, share_count: i32) -> Self {
        self.share_count = Some(share_count);
        self
    }

    pub fn tags(mut self, tags: String) -> Self {
        self.tags = Some(tags);
        self
    }

    pub fn mentions(mut self, mentions: String) -> Self {
        self.mentions = Some(mentions);
        self
    }

    /// Save the entity to database via TAO
    pub async fn save(self, tao: &Tao) -> AppResult<EntPost> {
        let current_time = current_time_millis();

        let entity = EntPost {
            id: 0, // TAO will generate the actual ID
            author_id: self.author_id.ok_or_else(|| crate::error::AppError::Validation(
                "Required field 'author_id' not provided".to_string()
            ))?,
            content: self.content.ok_or_else(|| crate::error::AppError::Validation(
                "Required field 'content' not provided".to_string()
            ))?,
            media_url: self.media_url,
            created_time: current_time,
            updated_time: Some(current_time),
            post_type: self.post_type.ok_or_else(|| crate::error::AppError::Validation(
                "Required field 'post_type' not provided".to_string()
            ))?,
            visibility: self.visibility,
            like_count: self.like_count.ok_or_else(|| crate::error::AppError::Validation(
                "Required field 'like_count' not provided".to_string()
            ))?,
            comment_count: self.comment_count.ok_or_else(|| crate::error::AppError::Validation(
                "Required field 'comment_count' not provided".to_string()
            ))?,
            share_count: self.share_count.ok_or_else(|| crate::error::AppError::Validation(
                "Required field 'share_count' not provided".to_string()
            ))?,
            tags: self.tags,
            mentions: self.mentions,
        };

        // Validate entity before saving
        let validation_errors = entity.validate()?;
        if !validation_errors.is_empty() {
            return Err(crate::error::AppError::Validation(
                format!("Validation failed: {}", validation_errors.join(", "))
            ));
        }

        // Serialize entity to bytes for TAO storage
        // Serialize entity to bytes for TAO storage
        let mut buffer = Vec::new();
        let mut cursor = Cursor::new(&mut buffer);
        let mut protocol = TCompactOutputProtocol::new(&mut cursor);
        entity.write_to_out_protocol(&mut protocol)
            .map_err(|e| crate::error::AppError::SerializationError(e.to_string()))?;
        let data = buffer;

        // Create object using TAO - TAO handles ID generation internally
        let generated_id = tao.obj_add("ent_post".to_string(), data, None).await?;

        // Create final entity with generated ID
        let mut final_entity = entity;
        final_entity.id = generated_id;

        println!("âœ… Created EntPost with TAO ID: {}", generated_id);

        Ok(final_entity)
    }

}

impl EntPost {
    /// Create a new entity builder
    pub fn create() -> EntPostBuilder {
        EntPostBuilder::new()
    }
}


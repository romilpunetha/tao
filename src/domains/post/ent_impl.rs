use std::sync::Arc;
// Generated Ent trait implementation for EntPost
// Generated by TAO Ent Framework - DO NOT EDIT
// Regenerate with: cargo run --bin entc generate

use crate::ent_framework::Entity;
use crate::error::AppResult;
use super::entity::EntPost;
use regex;
use crate::infrastructure::TaoOperations;
use crate::domains::user::EntUser;
use crate::domains::comment::EntComment;
use crate::domains::event::EntEvent;
use crate::domains::page::EntPage;
use crate::domains::group::EntGroup;

impl Entity for EntPost {
    const ENTITY_TYPE: &'static str = "ent_post";
    
    fn id(&self) -> i64 {
        self.id
    }

    fn validate(&self) -> AppResult<Vec<String>> {
        let mut errors = Vec::new();
        
        
        // Validate content (required)
        if self.content.trim().is_empty() {
            errors.push("content cannot be empty".to_string());
        }
        // Validate content min length
        if self.content.len() < 1 {
            errors.push("content must be at least 1 characters".to_string());
        }
        // Validate content max length
        if self.content.len() > 10000 {
            errors.push("content cannot exceed 10000 characters".to_string());
        }
        
        
        
        // Validate post type (required)
        if self.post_type.trim().is_empty() {
            errors.push("post type cannot be empty".to_string());
        }
        
        
        
        
        
        
        
        Ok(errors)
    }
}

impl EntPost {
    // Edge traversal methods
    
    /// Get author via TAO edge traversal
    pub async fn get_author(&self) -> AppResult<Vec<EntUser>> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "author".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntUser::gen_nullable(&(tao.clone() as Arc<dyn crate::infrastructure::TaoOperations>), Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count author via TAO edge traversal
    pub async fn count_author(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let count = tao.assoc_count(self.id(), "author".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Get comments via TAO edge traversal
    pub async fn get_comments(&self) -> AppResult<Vec<EntComment>> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "comments".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntComment::gen_nullable(&(tao.clone() as Arc<dyn crate::infrastructure::TaoOperations>), Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count comments via TAO edge traversal
    pub async fn count_comments(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let count = tao.assoc_count(self.id(), "comments".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Get liked by via TAO edge traversal
    pub async fn get_liked_by(&self) -> AppResult<Vec<EntUser>> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "liked_by".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntUser::gen_nullable(&(tao.clone() as Arc<dyn crate::infrastructure::TaoOperations>), Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count liked by via TAO edge traversal
    pub async fn count_liked_by(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let count = tao.assoc_count(self.id(), "liked_by".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Get mentioned users via TAO edge traversal
    pub async fn get_mentioned_users(&self) -> AppResult<Vec<EntUser>> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "mentioned_users".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntUser::gen_nullable(&(tao.clone() as Arc<dyn crate::infrastructure::TaoOperations>), Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count mentioned users via TAO edge traversal
    pub async fn count_mentioned_users(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let count = tao.assoc_count(self.id(), "mentioned_users".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Get appears on pages via TAO edge traversal
    pub async fn get_appears_on_pages(&self) -> AppResult<Vec<EntPage>> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "appears_on_pages".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntPage::gen_nullable(&(tao.clone() as Arc<dyn crate::infrastructure::TaoOperations>), Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count appears on pages via TAO edge traversal
    pub async fn count_appears_on_pages(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let count = tao.assoc_count(self.id(), "appears_on_pages".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add appears on page association via TAO
    pub async fn add_appears_on_page(&self, target_id: i64) -> AppResult<()> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        
        let assoc = crate::infrastructure::create_tao_association(
            self.id(),
            "appears_on_pages".to_string(),
            target_id,
            None // No metadata
        );
        
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove appears on page association via TAO
    pub async fn remove_appears_on_page(&self, target_id: i64) -> AppResult<bool> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        tao.assoc_delete(self.id(), "appears_on_pages".to_string(), target_id).await
    }
    
    /// Get shared in groups via TAO edge traversal
    pub async fn get_shared_in_groups(&self) -> AppResult<Vec<EntGroup>> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "shared_in_groups".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntGroup::gen_nullable(&(tao.clone() as Arc<dyn crate::infrastructure::TaoOperations>), Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count shared in groups via TAO edge traversal
    pub async fn count_shared_in_groups(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let count = tao.assoc_count(self.id(), "shared_in_groups".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add shared in group association via TAO
    pub async fn add_shared_in_group(&self, target_id: i64) -> AppResult<()> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        
        let assoc = crate::infrastructure::create_tao_association(
            self.id(),
            "shared_in_groups".to_string(),
            target_id,
            None // No metadata
        );
        
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove shared in group association via TAO
    pub async fn remove_shared_in_group(&self, target_id: i64) -> AppResult<bool> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        tao.assoc_delete(self.id(), "shared_in_groups".to_string(), target_id).await
    }
    
    /// Get related events via TAO edge traversal
    pub async fn get_related_events(&self) -> AppResult<Vec<EntEvent>> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "related_events".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntEvent::gen_nullable(&(tao.clone() as Arc<dyn crate::infrastructure::TaoOperations>), Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count related events via TAO edge traversal
    pub async fn count_related_events(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let count = tao.assoc_count(self.id(), "related_events".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add related event association via TAO
    pub async fn add_related_event(&self, target_id: i64) -> AppResult<()> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        
        let assoc = crate::infrastructure::create_tao_association(
            self.id(),
            "related_events".to_string(),
            target_id,
            None // No metadata
        );
        
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove related event association via TAO
    pub async fn remove_related_event(&self, target_id: i64) -> AppResult<bool> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        tao.assoc_delete(self.id(), "related_events".to_string(), target_id).await
    }
    
}


// Generated Ent trait implementation for EntUser
// Generated by TAO Ent Framework - DO NOT EDIT
// Regenerate with: cargo run --bin entc generate

use crate::framework::entity::ent_trait::Entity;
use crate::error::AppResult;
use super::entity::EntUser;
use crate::infrastructure::tao_core::tao_core::{TaoOperations, TaoObject};
use thrift::protocol::{TCompactInputProtocol, TSerializable};
use crate::infrastructure::global_tao::get_global_tao;
use std::io::Cursor;
use regex;
use crate::domains::event::EntEvent;
use crate::domains::page::EntPage;
use crate::domains::post::EntPost;
use crate::domains::group::EntGroup;

impl Entity for EntUser {
    const ENTITY_TYPE: &'static str = "ent_user";
    
    fn id(&self) -> i64 {
        self.id
    }

    fn validate(&self) -> AppResult<Vec<String>> {
        let mut errors = Vec::new();
        
        // Validate username (required)
        if self.username.trim().is_empty() {
            errors.push("username cannot be empty".to_string());
        }
        // Validate username min length
        if self.username.len() < 3 {
            errors.push("username must be at least 3 characters".to_string());
        }
        // Validate username max length
        if self.username.len() > 30 {
            errors.push("username cannot exceed 30 characters".to_string());
        }
        // Validate username pattern
        let username_regex = regex::Regex::new(r"^[a-zA-Z0-9_]+$").unwrap();
        if !username_regex.is_match(&self.username) {
            errors.push("username format is invalid".to_string());
        }
        
        // Validate email (required)
        if self.email.trim().is_empty() {
            errors.push("email cannot be empty".to_string());
        }
        // Validate email pattern
        let email_regex = regex::Regex::new(r"^[^\s@]+@[^\s@]+\.[^\s@]+$").unwrap();
        if !email_regex.is_match(&self.email) {
            errors.push("email format is invalid".to_string());
        }
        
        // Validate full name max length
        if let Some(ref val) = self.full_name {
            if val.len() > 100 {
                errors.push("full name cannot exceed 100 characters".to_string());
            }
        }
        
        // Validate bio max length
        if let Some(ref val) = self.bio {
            if val.len() > 500 {
                errors.push("bio cannot exceed 500 characters".to_string());
            }
        }
        
        
        
        
        
        
        Ok(errors)
    }
}

impl EntUser {
    /// Create an entity from a TaoObject
    pub(crate) async fn from_tao_object(tao_obj: TaoObject) -> AppResult<Option<EntUser>> {
        if tao_obj.otype != EntUser::ENTITY_TYPE {
            return Ok(None);
        }
        
        let mut cursor = Cursor::new(&tao_obj.data);
        let mut protocol = TCompactInputProtocol::new(&mut cursor);
        let entity = EntUser::read_from_in_protocol(&mut protocol)
            .map_err(|e| crate::error::AppError::SerializationError(e.to_string()))?;
        
        Ok(Some(entity))
    }

    // Edge traversal methods
    
    /// Get friends via TAO edge traversal
    pub async fn get_friends(&self) -> AppResult<Vec<EntUser>> {
        let tao = get_global_tao()?.clone();
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "friends".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(tao_obj) = tao.obj_get(id).await? {
                if let Some(entity) = EntUser::from_tao_object(tao_obj).await? {
                    results.push(entity);
                }
            }
        }
        
        Ok(results)
    }
    
    /// Count friends via TAO edge traversal
    pub async fn count_friends(&self) -> AppResult<i64> {
        let tao = get_global_tao()?.clone();
        let count = tao.assoc_count(self.id(), "friends".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add friend association via TAO
    pub async fn add_friend(&self, target_id: i64) -> AppResult<()> {
        let tao = get_global_tao()?.clone();
        // Fetch the EntUser to ensure it exists before creating an association
        let _friend = EntUser::from_tao_object(
            tao.obj_get(target_id).await?
                .ok_or_else(|| crate::error::AppError::NotFound(format!("EntUser with id {} not found", target_id)))?
        ).await?;

        let assoc = crate::infrastructure::tao_core::tao_core::create_tao_association(self.id(), "friends".to_string(), target_id, None);
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove friend association via TAO
    pub async fn remove_friend(&self, target_id: i64) -> AppResult<bool> {
        let tao = get_global_tao()?.clone();
        tao.assoc_delete(self.id(), "friends".to_string(), target_id).await
    }
    
    /// Get following via TAO edge traversal
    pub async fn get_following(&self) -> AppResult<Vec<EntUser>> {
        let tao = get_global_tao()?.clone();
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "following".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(tao_obj) = tao.obj_get(id).await? {
                if let Some(entity) = EntUser::from_tao_object(tao_obj).await? {
                    results.push(entity);
                }
            }
        }
        
        Ok(results)
    }
    
    /// Count following via TAO edge traversal
    pub async fn count_following(&self) -> AppResult<i64> {
        let tao = get_global_tao()?.clone();
        let count = tao.assoc_count(self.id(), "following".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add following association via TAO
    pub async fn add_following(&self, target_id: i64) -> AppResult<()> {
        let tao = get_global_tao()?.clone();
        // Fetch the EntUser to ensure it exists before creating an association
        let _following = EntUser::from_tao_object(
            tao.obj_get(target_id).await?
                .ok_or_else(|| crate::error::AppError::NotFound(format!("EntUser with id {} not found", target_id)))?
        ).await?;

        let assoc = crate::infrastructure::tao_core::tao_core::create_tao_association(self.id(), "following".to_string(), target_id, None);
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove following association via TAO
    pub async fn remove_following(&self, target_id: i64) -> AppResult<bool> {
        let tao = get_global_tao()?.clone();
        tao.assoc_delete(self.id(), "following".to_string(), target_id).await
    }
    
    /// Get followers via TAO edge traversal
    pub async fn get_followers(&self) -> AppResult<Vec<EntUser>> {
        let tao = get_global_tao()?.clone();
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "followers".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(tao_obj) = tao.obj_get(id).await? {
                if let Some(entity) = EntUser::from_tao_object(tao_obj).await? {
                    results.push(entity);
                }
            }
        }
        
        Ok(results)
    }
    
    /// Count followers via TAO edge traversal
    pub async fn count_followers(&self) -> AppResult<i64> {
        let tao = get_global_tao()?.clone();
        let count = tao.assoc_count(self.id(), "followers".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Get posts via TAO edge traversal
    pub async fn get_posts(&self) -> AppResult<Vec<EntPost>> {
        let tao = get_global_tao()?.clone();
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "posts".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(tao_obj) = tao.obj_get(id).await? {
                if let Some(entity) = EntPost::from_tao_object(tao_obj).await? {
                    results.push(entity);
                }
            }
        }
        
        Ok(results)
    }
    
    /// Count posts via TAO edge traversal
    pub async fn count_posts(&self) -> AppResult<i64> {
        let tao = get_global_tao()?.clone();
        let count = tao.assoc_count(self.id(), "posts".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Get liked posts via TAO edge traversal
    pub async fn get_liked_posts(&self) -> AppResult<Vec<EntPost>> {
        let tao = get_global_tao()?.clone();
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "liked_posts".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(tao_obj) = tao.obj_get(id).await? {
                if let Some(entity) = EntPost::from_tao_object(tao_obj).await? {
                    results.push(entity);
                }
            }
        }
        
        Ok(results)
    }
    
    /// Count liked posts via TAO edge traversal
    pub async fn count_liked_posts(&self) -> AppResult<i64> {
        let tao = get_global_tao()?.clone();
        let count = tao.assoc_count(self.id(), "liked_posts".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add liked post association via TAO
    pub async fn add_liked_post(&self, target_id: i64) -> AppResult<()> {
        let tao = get_global_tao()?.clone();
        // Fetch the EntPost to ensure it exists before creating an association
        let _liked_post = EntPost::from_tao_object(
            tao.obj_get(target_id).await?
                .ok_or_else(|| crate::error::AppError::NotFound(format!("EntPost with id {} not found", target_id)))?
        ).await?;

        let assoc = crate::infrastructure::tao_core::tao_core::create_tao_association(self.id(), "liked_posts".to_string(), target_id, None);
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove liked post association via TAO
    pub async fn remove_liked_post(&self, target_id: i64) -> AppResult<bool> {
        let tao = get_global_tao()?.clone();
        tao.assoc_delete(self.id(), "liked_posts".to_string(), target_id).await
    }
    
    /// Get groups via TAO edge traversal
    pub async fn get_groups(&self) -> AppResult<Vec<EntGroup>> {
        let tao = get_global_tao()?.clone();
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "groups".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(tao_obj) = tao.obj_get(id).await? {
                if let Some(entity) = EntGroup::from_tao_object(tao_obj).await? {
                    results.push(entity);
                }
            }
        }
        
        Ok(results)
    }
    
    /// Count groups via TAO edge traversal
    pub async fn count_groups(&self) -> AppResult<i64> {
        let tao = get_global_tao()?.clone();
        let count = tao.assoc_count(self.id(), "groups".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add group association via TAO
    pub async fn add_group(&self, target_id: i64) -> AppResult<()> {
        let tao = get_global_tao()?.clone();
        // Fetch the EntGroup to ensure it exists before creating an association
        let _group = EntGroup::from_tao_object(
            tao.obj_get(target_id).await?
                .ok_or_else(|| crate::error::AppError::NotFound(format!("EntGroup with id {} not found", target_id)))?
        ).await?;

        let assoc = crate::infrastructure::tao_core::tao_core::create_tao_association(self.id(), "groups".to_string(), target_id, None);
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove group association via TAO
    pub async fn remove_group(&self, target_id: i64) -> AppResult<bool> {
        let tao = get_global_tao()?.clone();
        tao.assoc_delete(self.id(), "groups".to_string(), target_id).await
    }
    
    /// Get followed pages via TAO edge traversal
    pub async fn get_followed_pages(&self) -> AppResult<Vec<EntPage>> {
        let tao = get_global_tao()?.clone();
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "followed_pages".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(tao_obj) = tao.obj_get(id).await? {
                if let Some(entity) = EntPage::from_tao_object(tao_obj).await? {
                    results.push(entity);
                }
            }
        }
        
        Ok(results)
    }
    
    /// Count followed pages via TAO edge traversal
    pub async fn count_followed_pages(&self) -> AppResult<i64> {
        let tao = get_global_tao()?.clone();
        let count = tao.assoc_count(self.id(), "followed_pages".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add followed page association via TAO
    pub async fn add_followed_page(&self, target_id: i64) -> AppResult<()> {
        let tao = get_global_tao()?.clone();
        // Fetch the EntPage to ensure it exists before creating an association
        let _followed_page = EntPage::from_tao_object(
            tao.obj_get(target_id).await?
                .ok_or_else(|| crate::error::AppError::NotFound(format!("EntPage with id {} not found", target_id)))?
        ).await?;

        let assoc = crate::infrastructure::tao_core::tao_core::create_tao_association(self.id(), "followed_pages".to_string(), target_id, None);
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove followed page association via TAO
    pub async fn remove_followed_page(&self, target_id: i64) -> AppResult<bool> {
        let tao = get_global_tao()?.clone();
        tao.assoc_delete(self.id(), "followed_pages".to_string(), target_id).await
    }
    
    /// Get attending events via TAO edge traversal
    pub async fn get_attending_events(&self) -> AppResult<Vec<EntEvent>> {
        let tao = get_global_tao()?.clone();
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "attending_events".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(tao_obj) = tao.obj_get(id).await? {
                if let Some(entity) = EntEvent::from_tao_object(tao_obj).await? {
                    results.push(entity);
                }
            }
        }
        
        Ok(results)
    }
    
    /// Count attending events via TAO edge traversal
    pub async fn count_attending_events(&self) -> AppResult<i64> {
        let tao = get_global_tao()?.clone();
        let count = tao.assoc_count(self.id(), "attending_events".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Add attending event association via TAO
    pub async fn add_attending_event(&self, target_id: i64) -> AppResult<()> {
        let tao = get_global_tao()?.clone();
        // Fetch the EntEvent to ensure it exists before creating an association
        let _attending_event = EntEvent::from_tao_object(
            tao.obj_get(target_id).await?
                .ok_or_else(|| crate::error::AppError::NotFound(format!("EntEvent with id {} not found", target_id)))?
        ).await?;

        let assoc = crate::infrastructure::tao_core::tao_core::create_tao_association(self.id(), "attending_events".to_string(), target_id, None);
        tao.assoc_add(assoc).await?;
        Ok(())
    }
    
    /// Remove attending event association via TAO
    pub async fn remove_attending_event(&self, target_id: i64) -> AppResult<bool> {
        let tao = get_global_tao()?.clone();
        tao.assoc_delete(self.id(), "attending_events".to_string(), target_id).await
    }
    
}


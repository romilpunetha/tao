use std::sync::Arc;
// Generated Ent trait implementation for EntUser
// Generated by TAO Ent Framework - DO NOT EDIT
// Regenerate with: cargo run --bin entc generate

use crate::ent_framework::Entity;
use crate::error::AppResult;
use super::entity::EntUser;
use regex;
use crate::infrastructure::TaoOperations;
use crate::domains::post::EntPost;
use crate::domains::page::EntPage;
use crate::domains::event::EntEvent;

impl Entity for EntUser {
    const ENTITY_TYPE: &'static str = "ent_user";

    fn id(&self) -> i64 {
        self.id
    }

    fn validate(&self) -> AppResult<Vec<String>> {
        let mut errors = Vec::new();

        // Validate username (required)
        if self.username.trim().is_empty() {
            errors.push("username cannot be empty".to_string());
        }
        // Validate username min length
        if self.username.len() < 3 {
            errors.push("username must be at least 3 characters".to_string());
        }
        // Validate username max length
        if self.username.len() > 30 {
            errors.push("username cannot exceed 30 characters".to_string());
        }
        // Validate username pattern
        let username_regex = regex::Regex::new(r"^[a-zA-Z0-9_]+$").unwrap();
        if !username_regex.is_match(&self.username) {
            errors.push("username format is invalid".to_string());
        }

        // Validate email (required)
        if self.email.trim().is_empty() {
            errors.push("email cannot be empty".to_string());
        }
        // Validate email pattern
        let email_regex = regex::Regex::new(r"^[^\s@]+@[^\s@]+\.[^\s@]+$").unwrap();
        if !email_regex.is_match(&self.email) {
            errors.push("email format is invalid".to_string());
        }

        // Validate full name max length
        if let Some(ref val) = self.full_name {
            if val.len() > 100 {
                errors.push("full name cannot exceed 100 characters".to_string());
            }
        }

        // Validate bio max length
        if let Some(ref val) = self.bio {
            if val.len() > 500 {
                errors.push("bio cannot exceed 500 characters".to_string());
            }
        }

        Ok(errors)
    }
}

impl EntUser {
    // Edge traversal methods

    /// Get friends via TAO edge traversal
    pub async fn get_friends(&self) -> AppResult<Vec<EntUser>> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "friends".to_string(), Some(100)).await?;

        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntUser::gen_nullable(&(tao.clone() as Arc<dyn crate::infrastructure::TaoOperations>), Some(id)).await? {
                results.push(entity);
            }
        }

        Ok(results)
    }

    /// Count friends via TAO edge traversal
    pub async fn count_friends(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let count = tao.assoc_count(self.id(), "friends".to_string()).await?;
        Ok(count as i64)
    }

    /// Add friend association via TAO
    pub async fn add_friend(&self, target_id: i64) -> AppResult<()> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;

        let assoc = crate::infrastructure::create_tao_association(
            self.id(),
            "friends".to_string(),
            target_id,
            None // No metadata
        );

        tao.assoc_add(assoc).await?;
        Ok(())
    }

    /// Remove friend association via TAO
    pub async fn remove_friend(&self, target_id: i64) -> AppResult<bool> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        tao.assoc_delete(self.id(), "friends".to_string(), target_id).await
    }

    /// Follow another user
    pub async fn follow_user(&self, target_user_id: i64) -> AppResult<()> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let assoc = crate::infrastructure::create_tao_association(
            self.id(),
            "follows".to_string(),
            target_user_id,
            None
        );
        tao.assoc_add(assoc).await?;
        Ok(())
    }

    /// Unfollow another user
    pub async fn unfollow_user(&self, target_user_id: i64) -> AppResult<bool> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        tao.assoc_delete(self.id(), "follows".to_string(), target_user_id).await
    }

    /// Like a post
    pub async fn like_post(&self, post_id: i64) -> AppResult<()> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        let assoc = crate::infrastructure::create_tao_association(
            self.id(),
            "liked".to_string(),
            post_id,
            None
        );
        tao.assoc_add(assoc).await?;
        Ok(())
    }

    /// Unlike a post
    pub async fn unlike_post(&self, post_id: i64) -> AppResult<bool> {
        let tao = crate::infrastructure::tao_core::get_tao_core().await?;
        tao.assoc_delete(self.id(), "liked".to_string(), post_id).await
    }
}
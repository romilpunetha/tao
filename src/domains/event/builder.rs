// Generated Unified Builder pattern implementation for EntEvent
// Generated by TAO Ent Framework - DO NOT EDIT
// Regenerate with: cargo run --bin entc generate

use crate::framework::entity::ent_trait::Entity;
use crate::framework::builder::ent_builder::EntBuilder;
use crate::framework::builder::has_tao::HasTao;
use crate::infrastructure::viewer::viewer::ViewerContext;
use crate::infrastructure::tao_core::tao_core::{TaoEntityBuilder, TaoOperations};
use crate::infrastructure::tao_core::tao_core::current_time_millis;
use crate::error::{AppResult, AppError};
use super::entity::EntEvent;
use std::sync::Arc;

#[derive(Debug, Default)]
pub struct EntEventBuilderState {
    name: Option<String>,
    description: Option<String>,
    event_time: Option<i64>,
    created_time: Option<i64>,
    pub(crate) tao: Option<Arc<dyn TaoOperations>>,
}

impl EntEventBuilderState {
    pub fn name(mut self, name: String) -> Self {
        self.name = Some(name);
        self
    }

    pub fn description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }

    pub fn event_time(mut self, event_time: i64) -> Self {
        self.event_time = Some(event_time);
        self
    }

    pub fn created_time(mut self, created_time: i64) -> Self {
        self.created_time = Some(created_time);
        self
    }

    /// Save the entity to database via TAO
    pub async fn savex(self) -> AppResult<EntEvent> {
        let tao = self.get_tao().ok_or_else(|| AppError::Internal("Tao instance not provided to builder".to_string()))?;
        tao.create_entity::<EntEvent>(self).await
    }

}

impl EntBuilder for EntEvent {
    type BuilderState = EntEventBuilderState;

    fn build(state: Self::BuilderState, id: i64) -> Result<Self, String> {
        let current_time = current_time_millis();

        Ok(EntEvent {
            id,
            name: state.name.ok_or_else(|| 
                "Required field 'name' not provided".to_string()
            )?,
            description: state.description,
            event_time: state.event_time.ok_or_else(|| 
                "Required field 'event_time' not provided".to_string()
            )?,
            created_time: current_time,
        })
    }

    fn entity_type() -> &'static str {
        "ent_event"
    }
}

impl HasTao for EntEventBuilderState {
    fn get_tao(&self) -> Option<Arc<dyn TaoOperations>> {
        self.tao.clone()
    }

    fn set_tao(&mut self, tao: Arc<dyn TaoOperations>) {
        self.tao = Some(tao);
    }
}

impl EntEvent {
    /// Create a new entity builder state (Meta's pattern: EntUser::create(vc))
    pub fn create(vc: Arc<ViewerContext>) -> EntEventBuilderState {
        let mut builder = EntEventBuilderState::default();
        // Extract TAO from viewer context following Meta's pattern
        builder.set_tao(Arc::clone(&vc.tao));
        builder
    }
}


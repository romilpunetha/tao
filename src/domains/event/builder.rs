// Generated Builder pattern implementation for EntEvent
// Generated by TAO Ent Framework - DO NOT EDIT
// Regenerate with: cargo run --bin entc generate

use async_trait::async_trait;
use crate::ent_framework::{Entity, get_tao};
use crate::infrastructure::tao::TaoOperations;
use crate::error::AppResult;
use crate::infrastructure::tao::current_time_millis;
use super::entity::EntEvent;
use thrift::protocol::TSerializable;

#[derive(Debug, Default)]
pub struct EntEventBuilder {
    name: Option<String>,
    description: Option<String>,
    event_time: Option<i64>,
    created_time: Option<i64>,
}

impl EntEventBuilder {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn name(mut self, name: String) -> Self {
        self.name = Some(name);
        self
    }

    pub fn description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }

    pub fn event_time(mut self, event_time: i64) -> Self {
        self.event_time = Some(event_time);
        self
    }

    pub fn created_time(mut self, created_time: i64) -> Self {
        self.created_time = Some(created_time);
        self
    }

    /// Save the entity to database via TAO
    pub async fn save(self) -> AppResult<EntEvent> {
        let current_time = current_time_millis();

        let entity = EntEvent {
            id: 0, // TAO will generate the actual ID
            name: self.name.ok_or_else(|| crate::error::AppError::Validation(
                "Required field 'name' not provided".to_string()
            ))?,
            description: self.description,
            event_time: self.event_time.ok_or_else(|| crate::error::AppError::Validation(
                "Required field 'event_time' not provided".to_string()
            ))?,
            created_time: current_time,
        };

        // Validate entity before saving
        let validation_errors = entity.validate()?;
        if !validation_errors.is_empty() {
            return Err(crate::error::AppError::Validation(
                format!("Validation failed: {}", validation_errors.join(", "))
            ));
        }

        // Serialize entity to bytes for TAO storage
        let data = {
            use thrift::protocol::{TCompactOutputProtocol, TOutputProtocol};
            use std::io::Cursor;
            let mut buffer = Vec::new();
            let mut cursor = Cursor::new(&mut buffer);
            let mut protocol = TCompactOutputProtocol::new(&mut cursor);
            entity.write_to_out_protocol(&mut protocol)
                .map_err(|e| crate::error::AppError::SerializationError(e.to_string()))?;
            buffer
        };

        // Get TAO singleton instance and save
        let tao = get_tao().await?;
        let tao = tao.lock().await;
        let generated_id = tao.obj_add("ent_event".to_string(), data).await?;

        // Create final entity with generated ID
        let mut final_entity = entity;
        final_entity.id = generated_id;

        println!("âœ… Created EntEvent with TAO ID: {}", generated_id);

        Ok(final_entity)
    }

}

impl EntEvent {
    /// Create a new entity builder
    pub fn create() -> EntEventBuilder {
        EntEventBuilder::new()
    }
}


// Generated Ent trait implementation for EntEvent
// Generated by TAO Ent Framework - DO NOT EDIT
// Regenerate with: cargo run --bin entc generate

use crate::ent_framework::Entity;
use crate::error::AppResult;
use super::entity::EntEvent;
use regex;
use crate::infrastructure::tao::TaoOperations;
use crate::domains::user::EntUser;
use crate::domains::post::EntPost;

impl Entity for EntEvent {
    const ENTITY_TYPE: &'static str = "ent_event";
    
    fn id(&self) -> i64 {
        self.id
    }

    fn validate(&self) -> AppResult<Vec<String>> {
        let mut errors = Vec::new();
        
        // Validate name (required)
        if self.name.trim().is_empty() {
            errors.push("name cannot be empty".to_string());
        }
        
        
        
        Ok(errors)
    }
}

impl EntEvent {
    // Edge traversal methods
    
    /// Get attendees via TAO edge traversal
    pub async fn get_attendees(&self) -> AppResult<Vec<EntUser>> {
        let tao = crate::infrastructure::tao::get_tao().await?;
        let tao = tao.lock().await;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "attendees".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntUser::gen_nullable(Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count attendees via TAO edge traversal
    pub async fn count_attendees(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao::get_tao().await?;
        let tao = tao.lock().await;
        let count = tao.assoc_count(self.id(), "attendees".to_string()).await?;
        Ok(count as i64)
    }
    
    /// Get related posts via TAO edge traversal
    pub async fn get_related_posts(&self) -> AppResult<Vec<EntPost>> {
        let tao = crate::infrastructure::tao::get_tao().await?;
        let tao = tao.lock().await;
        let neighbor_ids = tao.get_neighbor_ids(self.id(), "related_posts".to_string(), Some(100)).await?;
        
        let mut results = Vec::new();
        for id in neighbor_ids {
            if let Some(entity) = EntPost::gen_nullable(Some(id)).await? {
                results.push(entity);
            }
        }
        
        Ok(results)
    }
    
    /// Count related posts via TAO edge traversal
    pub async fn count_related_posts(&self) -> AppResult<i64> {
        let tao = crate::infrastructure::tao::get_tao().await?;
        let tao = tao.lock().await;
        let count = tao.assoc_count(self.id(), "related_posts".to_string()).await?;
        Ok(count as i64)
    }
    
}


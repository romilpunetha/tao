// Ent Code Generator - Generates Rust entity code from schema definitions
// Equivalent to Meta's entc (ent codegen) for automatic code generation

use std::collections::HashMap;
use crate::framework::{
    FieldDefinition, EdgeDefinition, EdgeType, EdgeCardinality, 
    FieldType, SchemaRegistry
};
use crate::framework::EntityType;

/// Code generator for entity schemas
pub struct EntCodeGenerator {
    registry: SchemaRegistry,
}

impl EntCodeGenerator {
    pub fn new(registry: SchemaRegistry) -> Self {
        Self { registry }
    }
    
    /// Generate enhanced Thrift schemas and compile them to Rust
    pub fn generate_all(&self) -> Result<HashMap<EntityType, String>, String> {
        // Validate schemas first
        self.registry.validate().map_err(|errors| {
            format!("Schema validation failed:\n{}", errors.join("\n"))
        })?;
        
        println!("âœ… Schema validation passed");
        
        // Step 1: Create domain-driven directory structure
        self.create_domain_directories()?;
        
        // Step 2: Generate enhanced Thrift files with TAO functionality
        self.generate_enhanced_thrift_files_domain_based()?;
        
        // Step 3: Compile Thrift files to Rust using thrift compiler
        self.compile_thrift_files_domain_based()?;
        
        // Step 4: Generate Ent trait implementations for each domain
        self.generate_ent_trait_implementations_domain_based()?;
        
        // Step 5: Generate domain module files and main domains/mod.rs
        self.generate_domain_modules()?;
        
        println!("ðŸŽ‰ Domain-driven entity generation completed successfully!");
        println!("ðŸ’¡ All entities organized by domain with complete functionality");
        println!("ðŸ“ Generated files in: src/domains/[entity]/");
        
        Ok(HashMap::new()) // Return empty since files are generated by Thrift
    }
    
    /// Create domain-driven directory structure
    fn create_domain_directories(&self) -> Result<(), String> {
        use std::fs;
        
        // Create main domains directory
        fs::create_dir_all("src/domains").map_err(|e| format!("Failed to create domains directory: {}", e))?;
        
        // Create domain directories for each entity
        for entity_type in self.registry.get_entity_types() {
            let domain_name = self.entity_domain_name(entity_type);
            let domain_path = format!("src/domains/{}", domain_name);
            fs::create_dir_all(&domain_path).map_err(|e| format!("Failed to create domain directory {}: {}", domain_path, e))?;
            
            // Create thrift subdirectory for generated thrift files
            let thrift_path = format!("{}/thrift", domain_path);
            fs::create_dir_all(&thrift_path).map_err(|e| format!("Failed to create thrift directory {}: {}", thrift_path, e))?;
        }
        
        println!("ðŸ“ Created domain directories structure");
        Ok(())
    }
    
    /// Get domain name from entity type (e.g., EntUser -> user)
    fn entity_domain_name(&self, entity_type: &EntityType) -> String {
        match entity_type {
            EntityType::EntUser => "user".to_string(),
            EntityType::EntPost => "post".to_string(),
            EntityType::EntComment => "comment".to_string(),
            EntityType::EntGroup => "group".to_string(),
            EntityType::EntPage => "page".to_string(),
            EntityType::EntEvent => "event".to_string(),
        }
    }
    
    /// Generate entity enhancements for Thrift-generated entities
    fn generate_entity_code(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
        edges: &[EdgeDefinition],
    ) -> Result<String, String> {
        let mut code = String::new();
        
        // Generate imports
        code.push_str(&self.generate_imports());
        
        // Re-export the Thrift-generated entity with enhancements
        code.push_str(&self.generate_thrift_reexport(entity_type)?);
        
        // Generate field validation implementation
        code.push_str(&self.generate_field_validation(entity_type, fields)?);
        
        // Generate edge helper methods
        code.push_str(&self.generate_edge_methods(entity_type, edges)?);
        
        // Generate Entity trait implementation
        code.push_str(&self.generate_entity_trait_impl(entity_type)?);
        
        // Generate TaoEntity trait implementation
        code.push_str(&self.generate_tao_entity_trait_impl(entity_type)?);
        
        Ok(code)
    }
    
    /// Generate a complete entity with Thrift serialization + TAO functionality
    fn generate_complete_entity(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
        edges: &[EdgeDefinition],
    ) -> Result<String, String> {
        let mut code = String::new();
        
        // Generate imports
        code.push_str(&self.generate_complete_imports());
        
        // Generate the complete struct with all functionality
        code.push_str(&self.generate_complete_struct(entity_type, fields)?);
        
        // Generate constructor and builder methods
        code.push_str(&self.generate_constructor_methods(entity_type, fields)?);
        
        // Generate Thrift serialization implementation
        code.push_str(&self.generate_complete_thrift_impl(entity_type, fields)?);
        
        // Generate validation methods
        code.push_str(&self.generate_validation_impl(entity_type, fields)?);
        
        // Generate TAO edge methods
        code.push_str(&self.generate_tao_edge_methods(entity_type, edges)?);
        
        // Generate Entity and TaoEntity trait implementations
        code.push_str(&self.generate_tao_trait_impls(entity_type)?);
        
        Ok(code)
    }
    
    fn generate_complete_imports(&self) -> String {
        r#"// Generated by TAO Ent Framework - Complete Entity with Thrift + TAO functionality
// DO NOT EDIT - Regenerate with `entc generate`

use std::io::Cursor;
use anyhow::Result;
use serde::{Deserialize, Serialize};
use thrift::protocol::{
    TInputProtocol, TOutputProtocol, TSerializable, TFieldIdentifier, 
    TStructIdentifier, TType, field_id, verify_required_field_exists,
    TBinaryInputProtocol, TBinaryOutputProtocol
};

"#.to_string()
    }
    
    fn generate_complete_struct(&self, entity_type: &EntityType, fields: &[FieldDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!(
            "#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct {} {{\n",
            struct_name
        );
        
        // Generate fields
        for field in fields {
            let rust_type = self.field_type_to_rust(&field.field_type, field.optional);
            code.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
        }
        
        code.push_str("}\n\n");
        Ok(code)
    }
    
    fn generate_constructor_methods(&self, entity_type: &EntityType, fields: &[FieldDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        
        // Generate main constructor with required fields
        let required_fields: Vec<_> = fields.iter().filter(|f| !f.optional).collect();
        code.push_str("    pub fn new(\n");
        
        for field in &required_fields {
            let rust_type = self.field_type_to_rust(&field.field_type, false);
            code.push_str(&format!("        {}: {},\n", field.name, rust_type));
        }
        
        code.push_str(&format!("    ) -> {} {{\n", struct_name));
        code.push_str(&format!("        {} {{\n", struct_name));
        
        // Set required fields
        for field in &required_fields {
            code.push_str(&format!("            {},\n", field.name));
        }
        
        // Set optional fields to None/defaults
        for field in fields.iter().filter(|f| f.optional) {
            if let Some(default) = &field.default {
                let default_value = self.default_to_rust(default);
                code.push_str(&format!("            {}: {},\n", field.name, default_value));
            } else {
                code.push_str(&format!("            {}: None,\n", field.name));
            }
        }
        
        code.push_str("        }\n    }\n\n");
        
        // Generate save method for adding entity to TAO
        code.push_str(&format!(
            "    /// Save this entity to the TAO database\n    pub async fn save(&self, database: &crate::core::TaoDatabase) -> Result<i64> {{\n        let data = self.to_tao_bytes()?;\n        let object_id = database.add_object(\n            Self::type_name(),\n            data\n        ).await?;\n        Ok(object_id)\n    }}\n\n"
        ));
        
        // Generate builder methods for optional fields
        for field in fields.iter().filter(|f| f.optional) {
            let rust_type = self.field_type_to_rust(&field.field_type, false);
            code.push_str(&format!(
                "    pub fn with_{}(mut self, {}: {}) -> Self {{\n",
                field.name, field.name, rust_type
            ));
            code.push_str(&format!("        self.{} = Some({});\n", field.name, field.name));
            code.push_str("        self\n    }\n\n");
        }
        
        code.push_str("}\n\n");
        Ok(code)
    }
    
    fn generate_complete_thrift_impl(&self, entity_type: &EntityType, fields: &[FieldDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl TSerializable for {} {{\n", struct_name);
        
        // Generate read_from_in_protocol
        code.push_str("    fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Self> {\n");
        code.push_str("        i_prot.read_struct_begin()?;\n");
        
        // Declare field variables
        for (index, field) in fields.iter().enumerate() {
            let field_index = index + 1;
            let base_type = match &field.field_type {
                FieldType::JSON => "String".to_string(),
                _ => {
                    let rust_type = self.field_type_to_rust(&field.field_type, true);
                    rust_type.strip_prefix("Option<").unwrap_or(&rust_type).strip_suffix(">").unwrap_or(&rust_type).to_string()
                }
            };
            code.push_str(&format!("        let mut f_{}: Option<{}> = None;\n", field_index, base_type));
        }
        
        code.push_str("        loop {\n");
        code.push_str("            let field_ident = i_prot.read_field_begin()?;\n");
        code.push_str("            if field_ident.field_type == TType::Stop {\n");
        code.push_str("                break;\n");
        code.push_str("            }\n");
        code.push_str("            let field_id = field_id(&field_ident)?;\n");
        code.push_str("            match field_id {\n");
        
        // Generate field parsing
        for (index, field) in fields.iter().enumerate() {
            let field_index = index + 1;
            let read_method = self.thrift_read_method(&field.field_type);
            code.push_str(&format!("                {} => {{\n", field_index));
            code.push_str(&format!("                    let val = i_prot.{}()?;\n", read_method));
            code.push_str(&format!("                    f_{} = Some(val);\n", field_index));
            code.push_str("                },\n");
        }
        
        code.push_str("                _ => {\n");
        code.push_str("                    i_prot.skip(field_ident.field_type)?;\n");
        code.push_str("                },\n");
        code.push_str("            };\n");
        code.push_str("            i_prot.read_field_end()?;\n");
        code.push_str("        }\n");
        code.push_str("        i_prot.read_struct_end()?;\n");
        
        // Verify required fields
        for (index, field) in fields.iter().enumerate().filter(|(_, f)| !f.optional) {
            let field_index = index + 1;
            code.push_str(&format!(
                "        verify_required_field_exists(\"{}.{}\", &f_{})?;\n",
                struct_name, field.name, field_index
            ));
        }
        
        // Construct entity
        code.push_str(&format!("        let ret = {} {{\n", struct_name));
        for (index, field) in fields.iter().enumerate() {
            let field_index = index + 1;
            if field.optional {
                match &field.field_type {
                    FieldType::JSON => {
                        code.push_str(&format!(
                            "            {}: f_{}.and_then(|s| serde_json::from_str(&s).ok()),\n", 
                            field.name, field_index
                        ));
                    },
                    _ => {
                        code.push_str(&format!("            {}: f_{},\n", field.name, field_index));
                    }
                }
            } else {
                match &field.field_type {
                    FieldType::JSON => {
                        code.push_str(&format!(
                            "            {}: f_{}.and_then(|s| serde_json::from_str(&s).ok()).expect(\"auto-generated code should have checked for presence of required fields\"),\n",
                            field.name, field_index
                        ));
                    },
                    _ => {
                        code.push_str(&format!(
                            "            {}: f_{}.expect(\"auto-generated code should have checked for presence of required fields\"),\n",
                            field.name, field_index
                        ));
                    }
                }
            }
        }
        code.push_str("        };\n");
        code.push_str("        Ok(ret)\n");
        code.push_str("    }\n\n");
        
        // Generate write_to_out_protocol
        code.push_str("    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {\n");
        code.push_str(&format!("        let struct_ident = TStructIdentifier::new(\"{}\");\n", struct_name));
        code.push_str("        o_prot.write_struct_begin(&struct_ident)?;\n");
        
        // Write fields
        for (index, field) in fields.iter().enumerate() {
            let field_index = index + 1;
            let thrift_type = self.thrift_type(&field.field_type);
            
            if field.optional {
                code.push_str(&format!("        if let Some(ref fld_var) = self.{} {{\n", field.name));
                code.push_str(&format!(
                    "            o_prot.write_field_begin(&TFieldIdentifier::new(\"{}\", {}, {}))?;\n",
                    field.name, thrift_type, field_index
                ));
                match field.field_type {
                    FieldType::String | FieldType::UUID | FieldType::Enum(_) => {
                        code.push_str("            o_prot.write_string(fld_var)?;\n");
                    },
                    FieldType::JSON => {
                        code.push_str("            let json_str = serde_json::to_string(fld_var).unwrap_or_default();\n");
                        code.push_str("            o_prot.write_string(&json_str)?;\n");
                    },
                    FieldType::Int64 | FieldType::Time => {
                        code.push_str("            o_prot.write_i64(*fld_var)?;\n");
                    },
                    FieldType::Int => {
                        code.push_str("            o_prot.write_i32(*fld_var)?;\n");
                    },
                    FieldType::Float => {
                        code.push_str("            o_prot.write_double(*fld_var)?;\n");
                    },
                    FieldType::Bool => {
                        code.push_str("            o_prot.write_bool(*fld_var)?;\n");
                    },
                    FieldType::Bytes => {
                        code.push_str("            o_prot.write_bytes(fld_var)?;\n");
                    },
                }
                code.push_str("            o_prot.write_field_end()?;\n");
                code.push_str("        }\n");
            } else {
                code.push_str(&format!(
                    "        o_prot.write_field_begin(&TFieldIdentifier::new(\"{}\", {}, {}))?;\n",
                    field.name, thrift_type, field_index
                ));
                match field.field_type {
                    FieldType::String | FieldType::UUID | FieldType::Enum(_) => {
                        code.push_str(&format!("        o_prot.write_string(&self.{})?;\n", field.name));
                    },
                    FieldType::JSON => {
                        code.push_str(&format!("        let json_str = serde_json::to_string(&self.{}).unwrap_or_default();\n", field.name));
                        code.push_str("        o_prot.write_string(&json_str)?;\n");
                    },
                    FieldType::Int64 | FieldType::Time => {
                        code.push_str(&format!("        o_prot.write_i64(self.{})?;\n", field.name));
                    },
                    FieldType::Int => {
                        code.push_str(&format!("        o_prot.write_i32(self.{})?;\n", field.name));
                    },
                    FieldType::Float => {
                        code.push_str(&format!("        o_prot.write_double(self.{})?;\n", field.name));
                    },
                    FieldType::Bool => {
                        code.push_str(&format!("        o_prot.write_bool(self.{})?;\n", field.name));
                    },
                    FieldType::Bytes => {
                        code.push_str(&format!("        o_prot.write_bytes(&self.{})?;\n", field.name));
                    },
                }
                code.push_str("        o_prot.write_field_end()?;\n");
            }
        }
        
        code.push_str("        o_prot.write_field_stop()?;\n");
        code.push_str("        o_prot.write_struct_end()\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
        
        Ok(code)
    }
    
    fn generate_validation_impl(&self, entity_type: &EntityType, fields: &[FieldDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        code.push_str("    /// Validate entity fields according to schema constraints\n");
        code.push_str("    pub fn validate(&self) -> Result<(), Vec<String>> {\n");
        code.push_str("        let mut errors = Vec::new();\n\n");
        
        for field in fields {
            for validator in &field.validators {
                let validation_code = match validator {
                    crate::framework::FieldValidator::MinLength(min) => {
                        if field.optional {
                            format!(
                                "        if let Some(ref val) = self.{} {{\n            if val.len() < {} {{\n                errors.push(format!(\"{} must be at least {} characters\"));\n            }}\n        }}\n",
                                field.name, min, field.name, min
                            )
                        } else {
                            format!(
                                "        if self.{}.len() < {} {{\n            errors.push(format!(\"{} must be at least {} characters\"));\n        }}\n",
                                field.name, min, field.name, min
                            )
                        }
                    },
                    crate::framework::FieldValidator::MaxLength(max) => {
                        if field.optional {
                            format!(
                                "        if let Some(ref val) = self.{} {{\n            if val.len() > {} {{\n                errors.push(format!(\"{} must be at most {} characters\"));\n            }}\n        }}\n",
                                field.name, max, field.name, max
                            )
                        } else {
                            format!(
                                "        if self.{}.len() > {} {{\n            errors.push(format!(\"{} must be at most {} characters\"));\n        }}\n",
                                field.name, max, field.name, max
                            )
                        }
                    },
                    crate::framework::FieldValidator::Pattern(pattern) => {
                        let regex_check = if field.optional {
                            format!(
                                "        if let Some(ref val) = self.{} {{\n            use regex::Regex;\n            let pattern = Regex::new(r\"{}\").unwrap();\n            if !pattern.is_match(val) {{\n                errors.push(format!(\"{} must match pattern: {}\"));\n            }}\n        }}\n",
                                field.name, pattern, field.name, pattern
                            )
                        } else {
                            format!(
                                "        {{\n            use regex::Regex;\n            let pattern = Regex::new(r\"{}\").unwrap();\n            if !pattern.is_match(&self.{}) {{\n                errors.push(format!(\"{} must match pattern: {}\"));\n            }}\n        }}\n",
                                pattern, field.name, field.name, pattern
                            )
                        };
                        regex_check
                    },
                    crate::framework::FieldValidator::Range(min, max) => {
                        format!(
                            "        if self.{} < {} || self.{} > {} {{\n            errors.push(format!(\"{} must be between {} and {}\"));\n        }}\n",
                            field.name, min, field.name, max, field.name, min, max
                        )
                    },
                    crate::framework::FieldValidator::Custom(func) => {
                        format!("        // TODO: Call custom validator: {}\n", func)
                    },
                };
                code.push_str(&validation_code);
            }
        }
        
        code.push_str("        \n        if errors.is_empty() {\n            Ok(())\n        } else {\n            Err(errors)\n        }\n    }\n");
        code.push_str("}\n\n");
        Ok(code)
    }
    
    fn generate_tao_edge_methods(&self, entity_type: &EntityType, edges: &[EdgeDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        code.push_str("    // TAO Edge methods for entity relationships\n");
        
        for edge in edges {
            let method_name = format!("get_{}", edge.name);
            let target_type = self.entity_struct_name(&edge.target_entity);
            let association_type = self.edge_to_association_type(&edge.name);
            
            let return_type = match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    format!("Vec<(i64, {})>", target_type)
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    format!("Option<(i64, {})>", target_type)
                },
            };
            
            code.push_str(&format!(
                "    /// Get {} entities via {} edge\n",
                target_type, edge.name
            ));
            code.push_str(&format!(
                "    pub async fn {}(database: &crate::core::TaoDatabase, entity_id: i64) -> Result<{}> {{\n",
                method_name, return_type
            ));
            
            match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    code.push_str(&format!(
                        "        let associations = database.get_associations_by_source(\n            entity_id,\n            \"{}\",\n            None\n        ).await?;\n\n",
                        association_type
                    ));
                    code.push_str("        let mut results = Vec::new();\n");
                    code.push_str("        for assoc in associations {\n");
                    code.push_str("            if let Ok(entity) = database.get_object_by_id(assoc.id2).await {\n");
                    code.push_str(&format!(
                        "                if let Ok(parsed) = thrift::protocol::TBinaryInputProtocol::new(\n                    std::io::Cursor::new(&entity.data), false\n                ).and_then(|mut proto| {}::read_from_in_protocol(&mut proto)) {{\n",
                        target_type
                    ));
                    code.push_str("                    results.push((assoc.id2, parsed));\n");
                    code.push_str("                }\n            }\n        }\n");
                    code.push_str("        Ok(results)\n");
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    code.push_str(&format!(
                        "        let associations = database.get_associations_by_source(\n            entity_id,\n            \"{}\",\n            Some(1)\n        ).await?;\n\n",
                        association_type
                    ));
                    code.push_str("        if let Some(assoc) = associations.first() {\n");
                    code.push_str("            if let Ok(entity) = database.get_object_by_id(assoc.id2).await {\n");
                    code.push_str(&format!(
                        "                if let Ok(parsed) = thrift::protocol::TBinaryInputProtocol::new(\n                    std::io::Cursor::new(&entity.data), false\n                ).and_then(|mut proto| {}::read_from_in_protocol(&mut proto)) {{\n",
                        target_type
                    ));
                    code.push_str("                    return Ok(Some((assoc.id2, parsed)));\n");
                    code.push_str("                }\n            }\n        }\n");
                    code.push_str("        Ok(None)\n");
                },
            }
            
            code.push_str("    }\n\n");
        }
        
        code.push_str("}\n\n");
        Ok(code)
    }
    
    fn generate_tao_trait_impls(&self, entity_type: &EntityType) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let code = format!(
            r#"// TAO trait implementations for entity identification and serialization
impl {} {{
    /// Get the entity type for this entity
    pub fn entity_type() -> crate::models::EntityType {{
        crate::models::EntityType::{:?}
    }}
    
    /// Get the entity type string
    pub fn type_name() -> &'static str {{
        "{}"
    }}
    
    /// Serialize this entity to bytes for TAO storage
    pub fn to_tao_bytes(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>> {{
        use thrift::protocol::{{TOutputProtocol, TBinaryOutputProtocol}};
        let mut buffer = Vec::new();
        let mut protocol = TBinaryOutputProtocol::new(&mut buffer, true);
        self.write_to_out_protocol(&mut protocol)?;
        Ok(buffer)
    }}
    
    /// Deserialize entity from TAO bytes
    pub fn from_tao_bytes(data: &[u8]) -> Result<Self, Box<dyn std::error::Error>> {{
        use thrift::protocol::{{TInputProtocol, TBinaryInputProtocol}};
        let mut cursor = std::io::Cursor::new(data);
        let mut protocol = TBinaryInputProtocol::new(&mut cursor, true);
        Ok(Self::read_from_in_protocol(&mut protocol)?)
    }}
}}
"#,
            struct_name, entity_type, entity_type.as_str()
        );
        
        Ok(code)
    }
    
    /// Convert field name to typedef name (e.g., "username" -> "Username")
    fn field_name_to_typedef(&self, field_name: &str) -> String {
        // Convert snake_case to PascalCase
        field_name.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                }
            })
            .collect()
    }
    
    /// Generate TAO service definition for an entity
    fn generate_tao_service(&self, struct_name: &str, edges: &[EdgeDefinition]) -> Result<String, String> {
        let mut service_content = format!(
            "// TAO service for {} - handles persistence and relationship traversal\n",
            struct_name
        );
        service_content.push_str(&format!("service {}Service {{\n", struct_name));
        
        // Validation method
        service_content.push_str(&format!(
            "  // Validate entity according to schema constraints\n  list<string> validate(1: {} entity),\n\n",
            struct_name
        ));
        
        // Persistence methods
        service_content.push_str(&format!(
            "  // Save entity to TAO database\n  i64 save(1: {} entity),\n\n",
            struct_name
        ));
        service_content.push_str(&format!(
            "  // Load entity from TAO database\n  {} load(1: i64 entity_id),\n\n",
            struct_name
        ));
        service_content.push_str(&format!(
            "  // Load multiple entities\n  list<{}> load_multi(1: list<i64> entity_ids),\n\n",
            struct_name
        ));
        
        // Note: Ent trait methods will be implemented via post-Thrift generation

        // TAO edge traversal methods (return IDs, not entities)
        for edge in edges {
            let method_name = format!("get_{}_ids", edge.name);
            let target_type = self.entity_struct_name(&edge.target_entity);
            
            let return_type = match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    "list<i64>".to_string()
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    "i64".to_string()
                },
            };
            
            service_content.push_str(&format!(
                "  // Get {} IDs via {} edge\n  {} {}(1: i64 entity_id),\n\n",
                target_type, edge.name, return_type, method_name
            ));
        }
        
        // Enhanced edge traversal methods that return serialized entity data
        // This avoids cross-entity type references in Thrift
        for edge in edges {
            let method_name = format!("gen_{}", edge.name);
            let target_type = self.entity_struct_name(&edge.target_entity);
            
            let return_type = match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    "list<binary>".to_string() // Return serialized entity data
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    "binary".to_string() // Return serialized entity data (throws if not found)
                },
            };
            
            service_content.push_str(&format!(
                "  // Load serialized {} data via {} edge\n  {} {}(1: i64 entity_id),\n\n",
                target_type, edge.name, return_type, method_name
            ));
        }
        
        service_content.push_str("}\n\n");
        Ok(service_content)
    }
    
    /// Generate Ent trait implementations for all entities
    fn generate_ent_trait_implementations(&self) -> Result<(), String> {
        use std::fs;
        
        for entity_type in [
            EntityType::EntUser,
            EntityType::EntPost,
            EntityType::EntComment,
            EntityType::EntGroup,
            EntityType::EntPage,
            EntityType::EntEvent,
        ] {
            if let Some(fields) = self.registry.get_fields(&entity_type) {
                if let Some(edges) = self.registry.get_edges(&entity_type) {
                    let trait_impl = self.generate_ent_trait_impl(&entity_type, &fields, &edges)?;
                    
                    // Write to entity_name_ent.rs file
                    let filename = format!("src/models/{}_ent.rs", entity_type.as_str());
                    fs::write(&filename, trait_impl)
                        .map_err(|e| format!("Failed to write Ent trait impl for {}: {}", entity_type.as_str(), e))?;
                    
                    println!("âœ… Generated Ent trait implementation: {}", filename);
                }
            }
        }
        
        Ok(())
    }
    
    /// Generate Ent trait implementations for all entities in domain structure
    fn generate_ent_trait_implementations_domain_based(&self) -> Result<(), String> {
        use std::fs;
        
        for entity_type in self.registry.get_entity_types() {
            let domain_name = self.entity_domain_name(entity_type);
            
            if let Some(fields) = self.registry.get_fields(&entity_type) {
                if let Some(edges) = self.registry.get_edges(&entity_type) {
                    let trait_impl = self.generate_domain_ent_trait_impl(&entity_type, &fields, &edges, &domain_name)?;
                    
                    // Write to domain/ent_impl.rs file
                    let filename = format!("src/domains/{}/ent_impl.rs", domain_name);
                    fs::write(&filename, trait_impl)
                        .map_err(|e| format!("Failed to write Ent trait impl for {} domain: {}", domain_name, e))?;
                    
                    println!("âœ… Generated Ent trait implementation: {}", filename);
                }
            }
        }
        
        Ok(())
    }
    
    /// Generate domain-specific Ent trait implementation
    fn generate_domain_ent_trait_impl(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
        edges: &[EdgeDefinition],
        domain_name: &str,
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let entity_type_str = entity_type.as_str();
        
        let mut impl_code = format!(
            "// Ent trait implementation for {}\n\
            // Generated by TAO Ent Framework - DO NOT EDIT\n\n\
            use async_trait::async_trait;\n\
            use crate::framework::Ent;\n\
            use crate::error::AppResult;\n\
            use super::entity::{{{}}};\n\n",
            struct_name, struct_name
        );
        
        // Implement Ent trait
        impl_code.push_str(&format!(
            "#[async_trait]\n\
            impl Ent for {} {{\n\
            const ENTITY_TYPE: &'static str = \"{}\";\n\n\
            fn id(&self) -> i64 {{\n\
            // TODO: Add id field to schema or use generated ID\n\
            0\n\
            }}\n\n\
            async fn gen_nullable(entity_id: Option<i64>) -> AppResult<Option<Self>> {{\n\
            match entity_id {{\n\
            Some(id) => {{\n\
            // TODO: Implement actual database lookup\n\
            // This should use TAO interface to load entity\n\
            todo!(\"Implement gen_nullable for {}\")\n\
            }},\n\
            None => Ok(None),\n\
            }}\n\
            }}\n\n\
            async fn gen_enforce(entity_id: i64) -> AppResult<Self> {{\n\
            // TODO: Implement actual database lookup with enforcement\n\
            // This should panic/error if entity not found\n\
            todo!(\"Implement gen_enforce for {}\")\n\
            }}\n\n\
            async fn gen_create(entity: Self) -> AppResult<Self> {{\n\
            // TODO: Implement entity creation via TAO\n\
            todo!(\"Implement gen_create for {}\")\n\
            }}\n\n\
            async fn gen_update(&mut self) -> AppResult<()> {{\n\
            // TODO: Implement entity update via TAO\n\
            todo!(\"Implement gen_update for {}\")\n\
            }}\n\n\
            async fn gen_delete(entity_id: i64) -> AppResult<bool> {{\n\
            // TODO: Implement entity deletion via TAO\n\
            todo!(\"Implement gen_delete for {}\")\n\
            }}\n\n\
            async fn gen_exists(entity_id: i64) -> AppResult<bool> {{\n\
            // TODO: Implement existence check via TAO\n\
            todo!(\"Implement gen_exists for {}\")\n\
            }}\n\n\
            async fn gen_load_many(entity_ids: Vec<i64>) -> AppResult<Vec<Option<Self>>> {{\n\
            // TODO: Implement batch loading via TAO\n\
            todo!(\"Implement gen_load_many for {}\")\n\
            }}\n\n\
            async fn gen_create_many(entities: Vec<Self>) -> AppResult<Vec<Self>> {{\n\
            // TODO: Implement batch creation via TAO\n\
            todo!(\"Implement gen_create_many for {}\")\n\
            }}\n\n\
            async fn gen_delete_many(entity_ids: Vec<i64>) -> AppResult<Vec<bool>> {{\n\
            // TODO: Implement batch deletion via TAO\n\
            todo!(\"Implement gen_delete_many for {}\")\n\
            }}\n\n\
            async fn gen_can_view(&self, viewer_id: Option<i64>) -> AppResult<bool> {{\n\
            // TODO: Implement privacy rules\n\
            Ok(true) // Default: allow all views\n\
            }}\n\n\
            async fn gen_can_edit(&self, viewer_id: Option<i64>) -> AppResult<bool> {{\n\
            // TODO: Implement edit permissions\n\
            Ok(true) // Default: allow all edits\n\
            }}\n\n\
            fn validate(&self) -> AppResult<Vec<String>> {{\n\
            let mut errors = Vec::new();\n",
            struct_name, entity_type_str, struct_name, struct_name, struct_name, struct_name, struct_name, struct_name, struct_name, struct_name, struct_name
        ));
        
        // Generate validation logic based on field constraints
        for field in fields {
            for validator in &field.validators {
                match validator {
                    crate::framework::FieldValidator::MinLength(min) => {
                        impl_code.push_str(&format!(
                            "        if self.{}.len() < {} {{\n\
                            errors.push(format!(\"{} must be at least {} characters\"));\n\
                            }}\n",
                            field.name, min, field.name, min
                        ));
                    },
                    crate::framework::FieldValidator::MaxLength(max) => {
                        impl_code.push_str(&format!(
                            "        if self.{}.len() > {} {{\n\
                            errors.push(format!(\"{} must be at most {} characters\"));\n\
                            }}\n",
                            field.name, max, field.name, max
                        ));
                    },
                    crate::framework::FieldValidator::Pattern(pattern) => {
                        impl_code.push_str(&format!(
                            "        // TODO: Add regex validation for {} with pattern: {}\n",
                            field.name, pattern
                        ));
                    },
                    _ => {}
                }
            }
        }
        
        impl_code.push_str(
            "        Ok(errors)\n\
            }\n\
            }\n\n"
        );
        
        // Generate edge traversal methods as additional impl block
        impl_code.push_str(&format!("impl {} {{\n", struct_name));
        
        for edge in edges {
            let method_name = format!("gen_{}", edge.name);
            let target_type = self.entity_struct_name(&edge.target_entity);
            
            let return_type = match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    format!("Vec<{}>", target_type)
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    format!("Option<{}>", target_type)
                },
            };
            
            impl_code.push_str(&format!(
                "    /// Load {} via {} edge\n\
                pub async fn {}(&self) -> AppResult<{}> {{\n\
                // TODO: Implement edge traversal via TAO\n\
                todo!(\"Implement {} edge traversal\")\n\
                }}\n\n",
                target_type, edge.name, method_name, return_type, edge.name
            ));
        }
        
        impl_code.push_str("}\n");
        Ok(impl_code)
    }
    
    /// Generate Ent trait implementation for a specific entity
    fn generate_ent_trait_impl(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
        edges: &[EdgeDefinition],
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let entity_type_str = entity_type.as_str();
        
        let mut impl_code = format!(
            "// Ent trait implementation for {}\n\
            // Generated by TAO Ent Framework - DO NOT EDIT\n\n\
            use async_trait::async_trait;\n\
            use crate::framework::Ent;\n\
            use crate::error::AppResult;\n\
            use super::{{{}}};\n\n",
            struct_name, struct_name
        );
        
        // Implement Ent trait
        impl_code.push_str(&format!(
            "#[async_trait]\n\
            impl Ent for {} {{\n\
            const ENTITY_TYPE: &'static str = \"{}\";\n\n\
            fn id(&self) -> i64 {{\n\
            // TODO: Add id field to schema or use generated ID\n\
            0\n\
            }}\n\n\
            async fn gen_nullable(entity_id: Option<i64>) -> AppResult<Option<Self>> {{\n\
            match entity_id {{\n\
            Some(id) => {{\n\
            // TODO: Implement actual database lookup\n\
            // This should use TAO interface to load entity\n\
            todo!(\"Implement gen_nullable for {}\")\n\
            }},\n\
            None => Ok(None),\n\
            }}\n\
            }}\n\n\
            async fn gen_enforce(entity_id: i64) -> AppResult<Self> {{\n\
            // TODO: Implement actual database lookup with enforcement\n\
            // This should panic/error if entity not found\n\
            todo!(\"Implement gen_enforce for {}\")\n\
            }}\n\n\
            async fn gen_create(entity: Self) -> AppResult<Self> {{\n\
            // TODO: Implement entity creation via TAO\n\
            todo!(\"Implement gen_create for {}\")\n\
            }}\n\n\
            async fn gen_update(&mut self) -> AppResult<()> {{\n\
            // TODO: Implement entity update via TAO\n\
            todo!(\"Implement gen_update for {}\")\n\
            }}\n\n\
            async fn gen_delete(entity_id: i64) -> AppResult<bool> {{\n\
            // TODO: Implement entity deletion via TAO\n\
            todo!(\"Implement gen_delete for {}\")\n\
            }}\n\n\
            async fn gen_exists(entity_id: i64) -> AppResult<bool> {{\n\
            // TODO: Implement existence check via TAO\n\
            todo!(\"Implement gen_exists for {}\")\n\
            }}\n\n\
            async fn gen_load_many(entity_ids: Vec<i64>) -> AppResult<Vec<Option<Self>>> {{\n\
            // TODO: Implement batch loading via TAO\n\
            todo!(\"Implement gen_load_many for {}\")\n\
            }}\n\n\
            async fn gen_create_many(entities: Vec<Self>) -> AppResult<Vec<Self>> {{\n\
            // TODO: Implement batch creation via TAO\n\
            todo!(\"Implement gen_create_many for {}\")\n\
            }}\n\n\
            async fn gen_delete_many(entity_ids: Vec<i64>) -> AppResult<Vec<bool>> {{\n\
            // TODO: Implement batch deletion via TAO\n\
            todo!(\"Implement gen_delete_many for {}\")\n\
            }}\n\n\
            async fn gen_can_view(&self, viewer_id: Option<i64>) -> AppResult<bool> {{\n\
            // TODO: Implement privacy rules\n\
            Ok(true) // Default: allow all views\n\
            }}\n\n\
            async fn gen_can_edit(&self, viewer_id: Option<i64>) -> AppResult<bool> {{\n\
            // TODO: Implement edit permissions\n\
            Ok(true) // Default: allow all edits\n\
            }}\n\n\
            fn validate(&self) -> AppResult<Vec<String>> {{\n\
            let mut errors = Vec::new();\n",
            struct_name, entity_type_str, struct_name, struct_name, struct_name, struct_name, struct_name, struct_name, struct_name, struct_name, struct_name
        ));
        
        // Generate validation logic based on field constraints
        for field in fields {
            for validator in &field.validators {
                match validator {
                    crate::framework::FieldValidator::MinLength(min) => {
                        impl_code.push_str(&format!(
                            "        if self.{}.len() < {} {{\n\
                            errors.push(format!(\"{} must be at least {} characters\"));\n\
                            }}\n",
                            field.name, min, field.name, min
                        ));
                    },
                    crate::framework::FieldValidator::MaxLength(max) => {
                        impl_code.push_str(&format!(
                            "        if self.{}.len() > {} {{\n\
                            errors.push(format!(\"{} must be at most {} characters\"));\n\
                            }}\n",
                            field.name, max, field.name, max
                        ));
                    },
                    crate::framework::FieldValidator::Pattern(pattern) => {
                        impl_code.push_str(&format!(
                            "        // TODO: Add regex validation for {} with pattern: {}\n",
                            field.name, pattern
                        ));
                    },
                    _ => {}
                }
            }
        }
        
        impl_code.push_str(
            "        Ok(errors)\n\
            }\n\
            }\n\n"
        );
        
        // Generate edge traversal methods as additional impl block
        impl_code.push_str(&format!("impl {} {{\n", struct_name));
        
        for edge in edges {
            let method_name = format!("gen_{}", edge.name);
            let target_type = self.entity_struct_name(&edge.target_entity);
            
            let return_type = match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    format!("Vec<{}>", target_type)
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    format!("Option<{}>", target_type)
                },
            };
            
            impl_code.push_str(&format!(
                "    /// Load {} via {} edge\n\
                pub async fn {}(&self) -> AppResult<{}> {{\n\
                // TODO: Implement edge traversal via TAO\n\
                todo!(\"Implement {} edge traversal\")\n\
                }}\n\n",
                target_type, edge.name, method_name, return_type, edge.name
            ));
        }
        
        impl_code.push_str("}\n");
        
        Ok(impl_code)
    }
    
    /// Generate models/mod.rs for Thrift-generated entities
    fn generate_models_mod_thrift_based(&self) -> Result<(), String> {
        use std::fs;
        
        let mod_content = r#"// Generated by TAO Ent Framework - Thrift-generated entities
// DO NOT EDIT - Regenerate with `entc generate`

// Import Thrift-generated modules
pub mod ent_user;
pub mod ent_post;
pub mod ent_comment;
pub mod ent_group;
pub mod ent_page;
pub mod ent_event;
pub mod tao_core;

// Import Ent trait implementations
pub mod ent_user_ent;
pub mod ent_post_ent;
pub mod ent_comment_ent;
pub mod ent_group_ent;
pub mod ent_page_ent;
pub mod ent_event_ent;

// Re-export Thrift-generated structs
pub use ent_user::*;
pub use ent_post::*;
pub use ent_comment::*;
pub use ent_group::*;
pub use ent_page::*;
pub use ent_event::*;
pub use tao_core::*;

// Re-export Ent trait from framework
pub use crate::framework::Ent;

// Entity type enumeration
#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum EntityType {
    EntUser,
    EntPost,
    EntComment,
    EntGroup,
    EntPage,
    EntEvent,
}

impl EntityType {
    pub fn as_str(&self) -> &'static str {
        match self {
            EntityType::EntUser => "ent_user",
            EntityType::EntPost => "ent_post",
            EntityType::EntComment => "ent_comment",
            EntityType::EntGroup => "ent_group",
            EntityType::EntPage => "ent_page",
            EntityType::EntEvent => "ent_event",
        }
    }
}

// Association types for TAO edges
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AssociationType {
    Friendship,
    Follow,
    FollowedBy,
    Like,
    LikedBy,
    PostAuthor,
    Membership,
    EventAttendance,
    CommentParent,
    Comments,
    MentionedUsers,
}

impl AssociationType {
    pub fn as_str(&self) -> &'static str {
        match self {
            AssociationType::Friendship => "friendship",
            AssociationType::Follow => "follow",
            AssociationType::FollowedBy => "followed_by",
            AssociationType::Like => "like",
            AssociationType::LikedBy => "liked_by",
            AssociationType::PostAuthor => "post_author",
            AssociationType::Membership => "membership",
            AssociationType::EventAttendance => "event_attendance",
            AssociationType::CommentParent => "comment_parent",
            AssociationType::Comments => "comments",
            AssociationType::MentionedUsers => "mentioned_users",
        }
    }
}
"#;
        
        fs::write("src/models/mod.rs", mod_content)
            .map_err(|e| format!("Failed to write models/mod.rs: {}", e))?;
        
        println!("âœ… Generated models/mod.rs for Thrift-generated entities");
        Ok(())
    }
    
    fn write_complete_entity_to_models(&self, entity_type: &EntityType, code: &str) -> Result<(), String> {
        use std::fs;
        use std::path::Path;
        
        let models_dir = Path::new("src/models");
        fs::create_dir_all(models_dir).map_err(|e| format!("Failed to create models directory: {}", e))?;
        
        let entity_name = entity_type.as_str();
        let filename = format!("{}.rs", entity_name);
        let file_path = models_dir.join(&filename);
        
        fs::write(&file_path, code)
            .map_err(|e| format!("Failed to write {}: {}", filename, e))?;
        
        println!("âœ… Generated complete entity: src/models/{}", filename);
        Ok(())
    }
    
    fn generate_core_tao_types(&self) -> Result<(), String> {
        use std::fs;
        use std::path::Path;
        
        let models_dir = Path::new("src/models");
        fs::create_dir_all(models_dir).map_err(|e| format!("Failed to create models directory: {}", e))?;
        
        let tao_core_content = r#"// Generated by TAO Ent Framework - Core TAO types
// DO NOT EDIT - Regenerate with `entc generate`

use serde::{Deserialize, Serialize};
use thrift::protocol::{
    TInputProtocol, TOutputProtocol, TSerializable, TFieldIdentifier, 
    TStructIdentifier, TType, field_id, verify_required_field_exists
};

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TaoObject {
    pub id: i64,
    pub object_type: String,
    pub data: Vec<u8>,
    pub created_time: i64,
    pub updated_time: i64,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TaoAssociation {
    pub id: i64,
    pub id1: i64,
    pub id2: i64,
    pub assoc_type: String,
    pub data: Option<Vec<u8>>,
    pub created_time: i64,
    pub updated_time: i64,
    pub time1: Option<i64>,
    pub time2: Option<i64>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TaoAssociationQuery {
    pub id1: i64,
    pub assoc_type: String,
    pub id2s: Option<Vec<i64>>,
    pub time_low: Option<i64>,
    pub time_high: Option<i64>,
    pub limit: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TaoIndex {
    pub name: String,
    pub fields: Vec<String>,
    pub unique: bool,
}

// TODO: Add TSerializable implementations for TaoObject, TaoAssociation, etc.
"#;
        
        fs::write(models_dir.join("tao_core.rs"), tao_core_content)
            .map_err(|e| format!("Failed to write tao_core.rs: {}", e))?;
        
        println!("âœ… Generated core TAO types: src/models/tao_core.rs");
        Ok(())
    }
    
    fn generate_models_mod_complete(&self) -> Result<(), String> {
        use std::fs;
        
        let mod_content = r#"// Generated by TAO Ent Framework - Complete entity modules
// DO NOT EDIT - Regenerate with `entc generate`

pub mod tao_core;
pub mod ent_user;
pub mod ent_post;
pub mod ent_comment;
pub mod ent_group;
pub mod ent_page;
pub mod ent_event;

// Re-export complete entities (with Thrift + TAO functionality)
pub use ent_user::EntUser;
pub use ent_post::EntPost;
pub use ent_comment::EntComment;
pub use ent_group::EntGroup;
pub use ent_page::EntPage;
pub use ent_event::EntEvent;

// Re-export core TAO types
pub use tao_core::{TaoObject, TaoAssociation, TaoIndex, TaoAssociationQuery};

#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum EntityType {
    EntUser,
    EntPost,
    EntComment,
    EntGroup,
    EntPage,
    EntEvent,
}

impl EntityType {
    pub fn as_str(&self) -> &'static str {
        match self {
            EntityType::EntUser => "ent_user",
            EntityType::EntPost => "ent_post",
            EntityType::EntComment => "ent_comment",
            EntityType::EntGroup => "ent_group",
            EntityType::EntPage => "ent_page",
            EntityType::EntEvent => "ent_event",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AssociationType {
    Friendship,
    Follow,
    FollowedBy,
    Like,
    LikedBy,
    PostAuthor,
    Membership,
    EventAttendance,
    CommentParent,
    Comments,
    MentionedUsers,
}

impl AssociationType {
    pub fn as_str(&self) -> &'static str {
        match self {
            AssociationType::Friendship => "friendship",
            AssociationType::Follow => "follow",
            AssociationType::FollowedBy => "followed_by",
            AssociationType::Like => "like",
            AssociationType::LikedBy => "liked_by",
            AssociationType::PostAuthor => "post_author",
            AssociationType::Membership => "membership",
            AssociationType::EventAttendance => "event_attendance",
            AssociationType::CommentParent => "comment_parent",
            AssociationType::Comments => "comments",
            AssociationType::MentionedUsers => "mentioned_users",
        }
    }
}

// Re-export association query for backwards compatibility
pub use tao_core::TaoAssociationQuery as AssociationQuery;
"#;
        
        fs::write("src/models/mod.rs", mod_content)
            .map_err(|e| format!("Failed to write models/mod.rs: {}", e))?;
        
        println!("âœ… Generated complete models/mod.rs");
        Ok(())
    }
    
    // Helper methods for Thrift generation
    fn thrift_read_method(&self, field_type: &FieldType) -> String {
        match field_type {
            FieldType::String => "read_string".to_string(),
            FieldType::Int => "read_i32".to_string(),
            FieldType::Int64 | FieldType::Time => "read_i64".to_string(),
            FieldType::Float => "read_double".to_string(),
            FieldType::Bool => "read_bool".to_string(),
            FieldType::UUID => "read_string".to_string(),
            FieldType::Bytes => "read_bytes".to_string(),
            FieldType::JSON => "read_string".to_string(),
            FieldType::Enum(_) => "read_string".to_string(),
        }
    }
    
    fn thrift_type(&self, field_type: &FieldType) -> String {
        match field_type {
            FieldType::String | FieldType::UUID | FieldType::JSON | FieldType::Enum(_) => "TType::String".to_string(),
            FieldType::Int => "TType::I32".to_string(),
            FieldType::Int64 | FieldType::Time => "TType::I64".to_string(),
            FieldType::Float => "TType::Double".to_string(),
            FieldType::Bool => "TType::Bool".to_string(),
            FieldType::Bytes => "TType::String".to_string(),
        }
    }
    
    fn generate_imports(&self) -> String {
        r#"// Generated by Ent Code Generator - DO NOT EDIT
// This file enhances Thrift-generated entities with TAO functionality
use anyhow::Result;
use crate::{
    entities::{Entity, TaoEntity},
    models::EntityType,
    tao_interface::TaoInterface,
};

"#.to_string()
    }
    
    /// Generate enhanced Thrift files with TAO services and validation
    fn generate_enhanced_thrift_files(&self) -> Result<(), String> {
        use std::fs;
        use std::path::Path;
        
        // Create thrift directory
        let thrift_dir = Path::new("thrift");
        fs::create_dir_all(thrift_dir).map_err(|e| format!("Failed to create thrift directory: {}", e))?;
        
        // Generate core TAO types first
        self.generate_core_thrift_files()?;
        
        for entity_type in [
            EntityType::EntUser,
            EntityType::EntPost,
            EntityType::EntComment,
            EntityType::EntGroup,
            EntityType::EntPage,
            EntityType::EntEvent,
        ] {
            if let (Some(fields), Some(edges)) = (
                self.registry.get_fields(&entity_type),
                self.registry.get_edges(&entity_type),
            ) {
                let thrift_content = self.generate_enhanced_thrift_content(&entity_type, fields, edges)?;
                let filename = format!("{}.thrift", entity_type.as_str());
                let filepath = thrift_dir.join(filename);
                
                fs::write(&filepath, thrift_content)
                    .map_err(|e| format!("Failed to write Thrift file {}: {}", filepath.display(), e))?;
                
                println!("âœ… Generated enhanced Thrift schema: {}", filepath.display());
            }
        }
        
        Ok(())
    }
    
    /// Generate enhanced Thrift files organized by domain
    fn generate_enhanced_thrift_files_domain_based(&self) -> Result<(), String> {
        use std::fs;
        use std::path::Path;
        
        // Generate core TAO types first (shared across domains)
        let core_thrift_dir = Path::new("src/domains");
        fs::create_dir_all(core_thrift_dir).map_err(|e| format!("Failed to create domains directory: {}", e))?;
        
        // Generate tao_core.thrift in domains root for shared types
        self.generate_core_thrift_files_in_domains()?;
        
        for entity_type in self.registry.get_entity_types() {
            let domain_name = self.entity_domain_name(entity_type);
            let domain_thrift_dir = Path::new("src/domains").join(&domain_name);
            
            if let (Some(fields), Some(edges)) = (
                self.registry.get_fields(&entity_type),
                self.registry.get_edges(&entity_type),
            ) {
                let thrift_content = self.generate_domain_thrift_content(&entity_type, fields, edges, &domain_name)?;
                let filename = "entity.thrift";
                let filepath = domain_thrift_dir.join(filename);
                
                fs::write(&filepath, thrift_content)
                    .map_err(|e| format!("Failed to write domain Thrift file {}: {}", filepath.display(), e))?;
                
                println!("âœ… Generated domain Thrift schema: {}", filepath.display());
            }
        }
        
        Ok(())
    }
    
    /// Generate core TAO Thrift files in domains directory
    fn generate_core_thrift_files_in_domains(&self) -> Result<(), String> {
        use std::fs;
        
        let core_content = r#"namespace rs tao_database.core

// Core TAO types and enums
typedef i64 TaoId
typedef i64 TaoTime
typedef string TaoType
typedef string AssocType

// TAO Association for edge relationships
struct TaoAssociation {
    1: required TaoId id1,          // Source entity ID
    2: required AssocType atype,    // Association type (e.g., "friendship", "like")
    3: required TaoId id2,          // Target entity ID
    4: required TaoTime time,       // Association timestamp
    5: optional string data,        // Optional metadata
}

// TAO Object for entities
struct TaoObject {
    1: required TaoId id,           // Entity ID
    2: required TaoType otype,      // Object type (e.g., "user", "post")
    3: required TaoTime time,       // Creation/update timestamp
    4: optional string data,        // Serialized entity data
}

// Association query result
struct TaoAssocQueryResult {
    1: required list<TaoAssociation> associations,
    2: optional string next_cursor,  // For pagination
}

// Object query result
struct TaoObjectQueryResult {
    1: required list<TaoObject> objects,
    2: optional string next_cursor,  // For pagination
}
"#;

        let filepath = "src/domains/tao_core.thrift";
        fs::write(filepath, core_content)
            .map_err(|e| format!("Failed to write core TAO types: {}", e))?;
        
        println!("âœ… Generated core TAO types: {}", filepath);
        Ok(())
    }
    
    /// Generate domain-specific Thrift content with enhanced functionality
    fn generate_domain_thrift_content(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
        edges: &[EdgeDefinition],
        domain_name: &str,
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let entity_type_str = entity_type.as_str();
        
        let mut thrift_content = format!(
            "namespace rs tao_database.domains.{}\n\n// Include core TAO types\ninclude \"../tao_core.thrift\"\n\n// {} - Enhanced entity with TAO functionality\n",
            domain_name, struct_name
        );
        
        // Generate validation typedefs for fields with validators
        thrift_content.push_str("// Field validation typedefs\n");
        for field in fields {
            if !field.validators.is_empty() {
                let typedef_name = format!("{}_{}", struct_name, field.name.to_uppercase());
                let base_type = match field.field_type {
                    FieldType::String => "string",
                    FieldType::Int | FieldType::Int64 => "i64",
                    FieldType::Float => "double",
                    FieldType::Bool => "bool",
                    _ => "string",
                };
                thrift_content.push_str(&format!("typedef {} {}\n", base_type, typedef_name));
            }
        }
        thrift_content.push_str("\n");
        
        // Generate the main entity struct
        thrift_content.push_str(&format!("struct {} {{\n", struct_name));
        for (index, field) in fields.iter().enumerate() {
            let field_id = index + 1;
            let required = if !field.optional { "required" } else { "optional" };
            let thrift_type = self.field_type_to_thrift(&field.field_type);
            thrift_content.push_str(&format!("    {}: {} {} {},\n", field_id, required, thrift_type, field.name));
        }
        thrift_content.push_str("}\n\n");
        
        // Generate TAO service for this entity
        thrift_content.push_str(&self.generate_domain_tao_service(entity_type, edges)?);
        
        Ok(thrift_content)
    }
    
    /// Generate domain-specific TAO service definitions
    fn generate_domain_tao_service(&self, entity_type: &EntityType, edges: &[EdgeDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let service_name = format!("{}Service", struct_name);
        
        let mut service_content = format!(
            "// TAO service for {} persistence and relationships\nservice {} {{\n",
            struct_name, service_name
        );
        
        // Basic CRUD operations
        service_content.push_str(&format!(
            "    // Core entity operations\n\
            {} get(1: i64 entity_id),\n\
            list<{}> get_many(1: list<i64> entity_ids),\n\
            {} create(1: {} entity),\n\
            void update(1: {} entity),\n\
            bool delete(1: i64 entity_id),\n\
            bool exists(1: i64 entity_id),\n\n",
            struct_name, struct_name, struct_name, struct_name, struct_name
        ));
        
        // Edge traversal methods
        service_content.push_str("    // Edge traversal methods\n");
        for edge in edges {
            let target_struct = self.entity_struct_name(&edge.target_entity);
            let method_name = format!("get_{}", edge.name);
            let ids_method_name = format!("get_{}_ids", edge.name);
            
            match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    service_content.push_str(&format!(
                        "    list<{}> {}(1: i64 source_id),\n\
                        list<i64> {}(1: i64 source_id),\n",
                        target_struct, method_name, ids_method_name
                    ));
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    service_content.push_str(&format!(
                        "    {} {}(1: i64 source_id),\n\
                        i64 {}(1: i64 source_id),\n",
                        target_struct, method_name, ids_method_name
                    ));
                },
            }
        }
        
        service_content.push_str("}\n\n");
        Ok(service_content)
    }
    
    /// Generate Thrift content from schema fields
    fn generate_thrift_content(&self, entity_type: &EntityType, fields: &[FieldDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let snake_name = entity_type.as_str();
        
        let mut thrift_content = format!(
            "namespace rs tao_database.models.{}\n\n// {} - Generated from Ent Schema\nstruct {} {{\n",
            snake_name, struct_name, struct_name
        );
        
        // Generate Thrift fields
        for (index, field) in fields.iter().enumerate() {
            let field_id = index + 1;
            let thrift_type = self.field_type_to_thrift(&field.field_type);
            let requirement = if field.optional { "optional" } else { "required" };
            
            thrift_content.push_str(&format!(
                "  {}: {} {} {},\n",
                field_id, requirement, thrift_type, field.name
            ));
        }
        
        thrift_content.push_str("}\n");
        Ok(thrift_content)
    }
    
    /// Generate enhanced Thrift content with TAO services and validation
    fn generate_enhanced_thrift_content(&self, entity_type: &EntityType, fields: &[FieldDefinition], edges: &[EdgeDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let snake_name = entity_type.as_str();
        
        let mut thrift_content = format!(
            "namespace rs {}\n\n",
            snake_name
        );
        
        // Include core TAO types
        thrift_content.push_str("include \"tao_core.thrift\"\n\n");
        
        // Note: Cross-entity references will use i64 IDs instead of direct struct references
        // This is the TAO pattern where entities reference each other by ID
        
        // Generate validation typedefs for fields with constraints
        for field in fields {
            if !field.validators.is_empty() {
                let typedef_name = self.field_name_to_typedef(&field.name);
                let base_type = self.field_type_to_thrift(&field.field_type);
                
                thrift_content.push_str(&format!(
                    "// Validated type for {}\n",
                    field.name
                ));
                thrift_content.push_str(&format!(
                    "typedef {} {} (\n",
                    base_type, typedef_name
                ));
                
                for validator in &field.validators {
                    match validator {
                        crate::framework::FieldValidator::MinLength(min) => {
                            thrift_content.push_str(&format!("    min_length = \"{}\",\n", min));
                        },
                        crate::framework::FieldValidator::MaxLength(max) => {
                            thrift_content.push_str(&format!("    max_length = \"{}\",\n", max));
                        },
                        crate::framework::FieldValidator::Pattern(pattern) => {
                            let escaped_pattern = pattern.replace("\\", "\\\\").replace("\"", "\\\"");
                            thrift_content.push_str(&format!("    pattern = \"{}\",\n", escaped_pattern));
                        },
                        crate::framework::FieldValidator::Range(min, max) => {
                            thrift_content.push_str(&format!("    min_value = \"{}\",\n", min));
                            thrift_content.push_str(&format!("    max_value = \"{}\",\n", max));
                        },
                        crate::framework::FieldValidator::Custom(func) => {
                            thrift_content.push_str(&format!("    validator = \"{}\",\n", func));
                        },
                    }
                }
                
                thrift_content.push_str(")\n\n");
            }
        }
        
        // Generate entity struct
        thrift_content.push_str(&format!(
            "// {} - Generated from Ent Schema with TAO functionality\nstruct {} {{\n",
            struct_name, struct_name
        ));
        
        // Generate Thrift fields using validated types where applicable
        for (index, field) in fields.iter().enumerate() {
            let field_id = index + 1;
            let field_type = if !field.validators.is_empty() {
                self.field_name_to_typedef(&field.name)
            } else {
                self.field_type_to_thrift(&field.field_type)
            };
            let requirement = if field.optional { "optional" } else { "required" };
            
            thrift_content.push_str(&format!(
                "  {}: {} {} {},\n",
                field_id, requirement, field_type, field.name
            ));
        }
        
        thrift_content.push_str("}\n\n");
        
        // Generate TAO service for this entity
        thrift_content.push_str(&self.generate_tao_service(&struct_name, edges)?);
        
        Ok(thrift_content)
    }
    
    /// Convert Ent field types to Thrift types
    fn field_type_to_thrift(&self, field_type: &FieldType) -> String {
        match field_type {
            FieldType::String => "string".to_string(),
            FieldType::Int => "i32".to_string(),
            FieldType::Int64 | FieldType::Time => "i64".to_string(),
            FieldType::Float => "double".to_string(),
            FieldType::Bool => "bool".to_string(),
            FieldType::UUID => "string".to_string(),
            FieldType::Bytes => "binary".to_string(),
            FieldType::JSON => "string".to_string(), // JSON as string in Thrift
            FieldType::Enum(_) => "string".to_string(), // Enums as strings for now
        }
    }
    
    /// Generate core TAO Thrift files
    fn generate_core_thrift_files(&self) -> Result<(), String> {
        use std::fs;
        use std::path::Path;
        
        // Generate tao_core.thrift
        let tao_core_content = r#"namespace rs tao_core

// Core TAO object type
struct TaoObject {
  1: required i64 id,
  2: required string object_type,
  3: required binary data,
  4: required i64 created_time,
  5: required i64 updated_time,
}

// TAO association type
struct TaoAssociation {
  1: required i64 id,
  2: required i64 id1,
  3: required i64 id2,
  4: required string assoc_type,
  5: optional binary data,
  6: required i64 created_time,
  7: required i64 updated_time,
  8: optional i64 time1,
  9: optional i64 time2,
}

// TAO association query
struct TaoAssociationQuery {
  1: required i64 id1,
  2: required string assoc_type,
  3: optional list<i64> id2s,
  4: optional i64 time_low,
  5: optional i64 time_high,
  6: optional i32 limit,
}

// TAO index for performance
struct TaoIndex {
  1: required string name,
  2: required list<string> fields,
  3: required bool unique,
}
"#;

        let thrift_dir = Path::new("thrift");
        fs::create_dir_all(thrift_dir).map_err(|e| format!("Failed to create thrift directory: {}", e))?;
        
        fs::write(thrift_dir.join("tao_core.thrift"), tao_core_content)
            .map_err(|e| format!("Failed to write tao_core.thrift: {}", e))?;
        
        println!("âœ… Generated core Thrift schema: thrift/tao_core.thrift");
        Ok(())
    }
    
    /// Compile Thrift files organized by domain
    fn compile_thrift_files_domain_based(&self) -> Result<(), String> {
        use std::process::Command;
        use std::path::Path;
        use std::fs;
        
        // First compile shared tao_core.thrift
        let tao_core_file = "src/domains/tao_core.thrift";
        if Path::new(tao_core_file).exists() {
            let output = Command::new("thrift")
                .arg("--gen")
                .arg("rs")
                .arg("-out")
                .arg("src/domains")
                .arg(tao_core_file)
                .output()
                .map_err(|e| format!("Failed to execute thrift compiler: {}", e))?;
            
            if !output.status.success() {
                return Err(format!(
                    "Thrift compilation failed for {}: {}",
                    tao_core_file,
                    String::from_utf8_lossy(&output.stderr)
                ));
            }
            
            println!("âœ… Compiled core TAO types: {}", tao_core_file);
        }
        
        // Compile domain-specific entity Thrift files
        for entity_type in self.registry.get_entity_types() {
            let domain_name = self.entity_domain_name(entity_type);
            let domain_dir = format!("src/domains/{}", domain_name);
            let thrift_file = format!("{}/entity.thrift", domain_dir);
            
            if Path::new(&thrift_file).exists() {
                let output = Command::new("thrift")
                    .arg("--gen")
                    .arg("rs")
                    .arg("-out")
                    .arg(&domain_dir)
                    .arg(&thrift_file)
                    .output()
                    .map_err(|e| format!("Failed to execute thrift compiler for {}: {}", domain_name, e))?;
                
                if !output.status.success() {
                    return Err(format!(
                        "Thrift compilation failed for {} domain ({}): {}",
                        domain_name,
                        thrift_file,
                        String::from_utf8_lossy(&output.stderr)
                    ));
                }
                
                println!("âœ… Compiled Thrift to Rust for {} domain: {}", domain_name, thrift_file);
            }
        }
        
        println!("ðŸŽ¯ All domain Thrift files compiled successfully");
        Ok(())
    }
    
    /// Compile Thrift files to Rust code
    fn compile_thrift_files(&self) -> Result<(), String> {
        use std::process::Command;
        use std::path::Path;
        use std::fs;
        
        // Create models directory
        let models_dir = Path::new("src/models");
        fs::create_dir_all(models_dir).map_err(|e| format!("Failed to create models directory: {}", e))?;
        
        // First compile tao_core.thrift
        let tao_core_file = "thrift/tao_core.thrift";
        if Path::new(tao_core_file).exists() {
            let output = Command::new("thrift")
                .arg("--gen")
                .arg("rs")
                .arg("-out")
                .arg("src/models")
                .arg(tao_core_file)
                .output()
                .map_err(|e| format!("Failed to execute thrift compiler: {}", e))?;
            
            if !output.status.success() {
                return Err(format!(
                    "Thrift compilation failed for {}: {}",
                    tao_core_file,
                    String::from_utf8_lossy(&output.stderr)
                ));
            }
            
            println!("âœ… Compiled Thrift to Rust: {}", tao_core_file);
        }
        
        // Compile entity Thrift files
        for entity_type in [
            EntityType::EntUser,
            EntityType::EntPost,
            EntityType::EntComment,
            EntityType::EntGroup,
            EntityType::EntPage,
            EntityType::EntEvent,
        ] {
            let filename = format!("thrift/{}.thrift", entity_type.as_str());
            if Path::new(&filename).exists() {
                let output = Command::new("thrift")
                    .arg("--gen")
                    .arg("rs")
                    .arg("-out")
                    .arg("src/models")
                    .arg(&filename)
                    .output()
                    .map_err(|e| format!("Failed to execute thrift compiler: {}", e))?;
                
                if !output.status.success() {
                    return Err(format!(
                        "Thrift compilation failed for {}: {}",
                        filename,
                        String::from_utf8_lossy(&output.stderr)
                    ));
                }
                
                println!("âœ… Compiled Thrift to Rust: {}", filename);
            }
        }
        
        // Compile core Thrift file
        let output = Command::new("thrift")
            .arg("--gen")
            .arg("rs")
            .arg("-out")
            .arg("src/models")
            .arg("thrift/tao_core.thrift")
            .output()
            .map_err(|e| format!("Failed to execute thrift compiler: {}", e))?;
        
        if !output.status.success() {
            return Err(format!(
                "Thrift compilation failed for tao_core.thrift: {}",
                String::from_utf8_lossy(&output.stderr)
            ));
        }
        
        println!("âœ… Compiled Thrift to Rust: thrift/tao_core.thrift");
        
        // Generate models/mod.rs
        self.generate_models_mod()?;
        
        Ok(())
    }
    
    /// Generate the models/mod.rs file with all re-exports
    fn generate_models_mod(&self) -> Result<(), String> {
        use std::fs;
        
        let mod_content = r#"// Generated by Ent Code Generator - Thrift entity modules
pub mod tao_core;
pub mod ent_user;
pub mod ent_post;
pub mod ent_comment;
pub mod ent_group;
pub mod ent_page;
pub mod ent_event;

// Re-export Thrift-generated structs
pub use ent_user::EntUser;
pub use ent_post::EntPost;
pub use ent_comment::EntComment;
pub use ent_group::EntGroup;
pub use ent_page::EntPage;
pub use ent_event::EntEvent;

// Re-export core TAO types
pub use tao_core::{TaoObject, TaoAssociation, TaoIndex, TaoAssociationQuery};

#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum EntityType {
    EntUser,
    EntPost,
    EntComment,
    EntGroup,
    EntPage,
    EntEvent,
}

impl EntityType {
    pub fn as_str(&self) -> &'static str {
        match self {
            EntityType::EntUser => "ent_user",
            EntityType::EntPost => "ent_post",
            EntityType::EntComment => "ent_comment",
            EntityType::EntGroup => "ent_group",
            EntityType::EntPage => "ent_page",
            EntityType::EntEvent => "ent_event",
        }
    }
}

impl AssociationType {
    pub fn as_str(&self) -> &'static str {
        match self {
            AssociationType::Friendship => "friendship",
            AssociationType::Follow => "follow",
            AssociationType::FollowedBy => "followed_by",
            AssociationType::Like => "like",
            AssociationType::LikedBy => "liked_by",
            AssociationType::PostAuthor => "post_author",
            AssociationType::Membership => "membership",
            AssociationType::EventAttendance => "event_attendance",
            AssociationType::CommentParent => "comment_parent",
            AssociationType::Comments => "comments",
            AssociationType::MentionedUsers => "mentioned_users",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AssociationType {
    Friendship,
    Follow,
    FollowedBy,
    Like,
    LikedBy,
    PostAuthor,
    Membership,
    EventAttendance,
    CommentParent,
    Comments,
    MentionedUsers,
}

// Re-export association query for backwards compatibility
pub use tao_core::TaoAssociationQuery as AssociationQuery;
"#;
        
        fs::write("src/models/mod.rs", mod_content)
            .map_err(|e| format!("Failed to write models/mod.rs: {}", e))?;
        
        println!("âœ… Generated models/mod.rs");
        Ok(())
    }
    
    fn generate_thrift_reexport(&self, entity_type: &EntityType) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let snake_name = struct_name.to_lowercase().replace("ent", "ent_");
        
        Ok(format!(
            r#"// Re-export Thrift-generated entity with enhanced functionality
pub use crate::models::{}::{};

"#,
            snake_name, struct_name
        ))
    }
    
    fn generate_constructor_extensions(&self, entity_type: &EntityType, fields: &[FieldDefinition]) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        
        // Generate builder methods for optional fields
        for field in fields.iter().filter(|f| f.optional) {
            let rust_type = self.field_type_to_rust(&field.field_type, false);
            code.push_str(&format!(
                "    \n    pub fn with_{}(mut self, {}: {}) -> Self {{\n",
                field.name, field.name, rust_type
            ));
            code.push_str(&format!("        self.{} = Some({});\n", field.name, field.name));
            code.push_str("        self\n    }\n");
        }
        
        code.push_str("}\n\n");
        Ok(code)
    }
    
    
    fn generate_field_validation(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        code.push_str("    /// Validate entity fields according to schema constraints\n");
        code.push_str("    pub fn validate(&self) -> Result<(), Vec<String>> {\n");
        code.push_str("        let mut errors = Vec::new();\n\n");
        
        for field in fields {
            // Generate validation for each field based on validators
            for validator in &field.validators {
                let validation_code = match validator {
                    crate::framework::FieldValidator::MinLength(min) => {
                        if field.optional {
                            format!(
                                "        if let Some(ref val) = self.{} {{\n            if val.len() < {} {{\n                errors.push(format!(\"{} must be at least {} characters\"));\n            }}\n        }}\n",
                                field.name, min, field.name, min
                            )
                        } else {
                            format!(
                                "        if self.{}.len() < {} {{\n            errors.push(format!(\"{} must be at least {} characters\"));\n        }}\n",
                                field.name, min, field.name, min
                            )
                        }
                    },
                    crate::framework::FieldValidator::MaxLength(max) => {
                        if field.optional {
                            format!(
                                "        if let Some(ref val) = self.{} {{\n            if val.len() > {} {{\n                errors.push(format!(\"{} must be at most {} characters\"));\n            }}\n        }}\n",
                                field.name, max, field.name, max
                            )
                        } else {
                            format!(
                                "        if self.{}.len() > {} {{\n            errors.push(format!(\"{} must be at most {} characters\"));\n        }}\n",
                                field.name, max, field.name, max
                            )
                        }
                    },
                    crate::framework::FieldValidator::Pattern(pattern) => {
                        let regex_check = if field.optional {
                            format!(
                                "        if let Some(ref val) = self.{} {{\n            use regex::Regex;\n            let pattern = Regex::new(r\"{}\").unwrap();\n            if !pattern.is_match(val) {{\n                errors.push(format!(\"{} must match pattern: {}\"));\n            }}\n        }}\n",
                                field.name, pattern, field.name, pattern
                            )
                        } else {
                            format!(
                                "        {{\n            use regex::Regex;\n            let pattern = Regex::new(r\"{}\").unwrap();\n            if !pattern.is_match(&self.{}) {{\n                errors.push(format!(\"{} must match pattern: {}\"));\n            }}\n        }}\n",
                                pattern, field.name, field.name, pattern
                            )
                        };
                        regex_check
                    },
                    crate::framework::FieldValidator::Range(min, max) => {
                        format!(
                            "        if self.{} < {} || self.{} > {} {{\n            errors.push(format!(\"{} must be between {} and {}\"));\n        }}\n",
                            field.name, min, field.name, max, field.name, min, max
                        )
                    },
                    crate::framework::FieldValidator::Custom(func) => {
                        format!("        // TODO: Call custom validator: {}\n", func)
                    },
                };
                code.push_str(&validation_code);
            }
        }
        
        code.push_str("        \n        if errors.is_empty() {\n            Ok(())\n        } else {\n            Err(errors)\n        }\n    }\n");
        code.push_str("}\n\n");
        Ok(code)
    }
    
    fn generate_edge_methods(
        &self,
        entity_type: &EntityType,
        edges: &[EdgeDefinition],
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        
        for edge in edges {
            let method_name = match edge.edge_type {
                EdgeType::To => format!("get_{}", edge.name),
                EdgeType::From => format!("get_{}", edge.name),
            };
            
            let target_type = self.entity_struct_name(&edge.target_entity);
            let return_type = match edge.cardinality {
                EdgeCardinality::OneToOne => {
                    if edge.required {
                        format!("({}, {})", "i64", target_type)
                    } else {
                        format!("Option<({}, {})>", "i64", target_type)
                    }
                },
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    format!("Vec<({}, {})>", "i64", target_type)
                },
                EdgeCardinality::ManyToOne => {
                    format!("Option<({}, {})>", "i64", target_type)
                },
            };
            
            // Map edge names to association types
            let assoc_type = self.edge_to_association_type(&edge.name);
            let target_entity_type_str = edge.target_entity.as_str();
            
            code.push_str(&format!(
                "    /// Get {} entities via {} edge\n",
                self.entity_struct_name(&edge.target_entity),
                edge.name
            ));
            code.push_str(&format!(
                "    pub async fn {}(tao: &TaoInterface, entity_id: i64) -> Result<{}> {{\n",
                method_name, return_type
            ));
            
            match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    code.push_str(&format!(
                        "        let entities = tao.get_associated_entities::<{}>(entity_id, {}, \"{}\", None).await?;\n",
                        self.entity_struct_name(&edge.target_entity),
                        assoc_type,
                        target_entity_type_str
                    ));
                    code.push_str("        Ok(entities)\n");
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    code.push_str(&format!(
                        "        let entities = tao.get_associated_entities::<{}>(entity_id, {}, \"{}\", Some(1)).await?;\n",
                        self.entity_struct_name(&edge.target_entity),
                        assoc_type,
                        target_entity_type_str
                    ));
                    if edge.required {
                        code.push_str("        entities.into_iter().next().ok_or_else(|| anyhow::anyhow!(\"Required relationship not found\"))\n");
                    } else {
                        code.push_str("        Ok(entities.into_iter().next())\n");
                    }
                },
            }
            
            code.push_str("    }\n\n");
        }
        
        code.push_str("}\n\n");
        Ok(code)
    }

    fn edge_to_association_type(&self, edge_name: &str) -> String {
        // Map edge names to AssociationType enum variants
        match edge_name {
            "friends" => "crate::models::AssociationType::Friendship".to_string(),
            "following" => "crate::models::AssociationType::Follow".to_string(),
            "followers" => "crate::models::AssociationType::FollowedBy".to_string(),
            "posts" => "crate::models::AssociationType::PostAuthor".to_string(),
            "liked_posts" => "crate::models::AssociationType::Like".to_string(),
            "groups" => "crate::models::AssociationType::Membership".to_string(),
            "followed_pages" => "crate::models::AssociationType::Follow".to_string(),
            "attending_events" => "crate::models::AssociationType::EventAttendance".to_string(),
            "members" => "crate::models::AssociationType::Membership".to_string(),
            "author" => "crate::models::AssociationType::PostAuthor".to_string(),
            "post" => "crate::models::AssociationType::CommentParent".to_string(),
            "comments" => "crate::models::AssociationType::Comments".to_string(),
            "liked_by" => "crate::models::AssociationType::LikedBy".to_string(),
            "mentioned_users" => "crate::models::AssociationType::MentionedUsers".to_string(),
            "appears_on_pages" => "crate::models::AssociationType::Follow".to_string(), // Use existing Follow
            "shared_in_groups" => "crate::models::AssociationType::Membership".to_string(), // Use existing Membership
            "related_events" => "crate::models::AssociationType::EventAttendance".to_string(), // Use existing EventAttendance
            "attendees" => "crate::models::AssociationType::EventAttendance".to_string(), // Use existing EventAttendance
            "related_posts" => "crate::models::AssociationType::PostAuthor".to_string(), // Use existing PostAuthor
            _ => format!("crate::models::AssociationType::{}", edge_name.to_uppercase()),
        }
    }
    
    fn generate_entity_trait_impl(&self, entity_type: &EntityType) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let code = format!(
            r#"impl Entity for {} {{
    fn entity_type() -> EntityType {{
        EntityType::{:?}
    }}
}}

"#,
            struct_name, entity_type
        );
        
        Ok(code)
    }
    
    fn generate_tao_entity_trait_impl(&self, entity_type: &EntityType) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        
        let code = format!(
            r#"impl TaoEntity for {} {{}}

"#,
            struct_name
        );
        
        Ok(code)
    }
    
    fn entity_struct_name(&self, entity_type: &EntityType) -> String {
        match entity_type {
            EntityType::EntUser => "EntUser".to_string(),
            EntityType::EntPost => "EntPost".to_string(),
            EntityType::EntComment => "EntComment".to_string(),
            EntityType::EntGroup => "EntGroup".to_string(),
            EntityType::EntPage => "EntPage".to_string(),
            EntityType::EntEvent => "EntEvent".to_string(),
        }
    }
    
    fn field_type_to_rust(&self, field_type: &FieldType, optional: bool) -> String {
        let base_type = match field_type {
            FieldType::String => "String".to_string(),
            FieldType::Int => "i32".to_string(),
            FieldType::Int64 => "i64".to_string(),
            FieldType::Float => "f64".to_string(),
            FieldType::Bool => "bool".to_string(),
            FieldType::Time => "i64".to_string(), // Unix timestamp
            FieldType::UUID => "String".to_string(), // UUID as string
            FieldType::Bytes => "Vec<u8>".to_string(),
            FieldType::JSON => "serde_json::Value".to_string(),
            FieldType::Enum(_variants) => {
                // TODO: Generate enum types
                "String".to_string()
            },
        };
        
        if optional {
            format!("Option<{}>", base_type)
        } else {
            base_type
        }
    }
    
    fn default_to_rust(&self, default: &crate::framework::FieldDefault) -> String {
        match default {
            crate::framework::FieldDefault::String(s) => format!("Some(\"{}\".to_string())", s),
            crate::framework::FieldDefault::Int(i) => format!("Some({})", i),
            crate::framework::FieldDefault::Int64(i) => format!("Some({})", i),
            crate::framework::FieldDefault::Float(f) => format!("Some({})", f),
            crate::framework::FieldDefault::Bool(b) => format!("Some({})", b),
            crate::framework::FieldDefault::Function(func) => {
                format!("Some({}())", func) // TODO: Call dynamic function
            },
        }
    }
    
    /// Generate domain module files and main domains/mod.rs
    fn generate_domain_modules(&self) -> Result<(), String> {
        use std::fs;
        
        // Generate individual domain mod.rs files
        for entity_type in self.registry.get_entity_types() {
            let domain_name = self.entity_domain_name(entity_type);
            let struct_name = self.entity_struct_name(entity_type);
            
            let domain_mod_content = format!(
                "// {} Domain Module\n\
                // Generated by TAO Ent Framework - DO NOT EDIT\n\n\
                // Re-export schema definition\n\
                pub mod schema;\n\n\
                // Thrift-generated entity\n\
                pub mod entity;\n\
                pub use entity::*;\n\n\
                // Ent trait implementation\n\
                pub mod ent_impl;\n\
                pub use ent_impl::*;\n\n\
                // Domain-specific extensions (create these manually)\n\
                // pub mod hooks;      // Custom entity hooks\n\
                // pub mod privacy;    // Privacy policies\n\
                // pub mod validation; // Custom validation logic\n\n\
                // Re-export main entity type for convenience\n\
                pub use entity::{{{}}};\n\
                pub use crate::framework::Ent;\n",
                struct_name, struct_name
            );
            
            let domain_mod_path = format!("src/domains/{}/mod.rs", domain_name);
            fs::write(&domain_mod_path, domain_mod_content)
                .map_err(|e| format!("Failed to write domain mod file {}: {}", domain_mod_path, e))?;
            
            println!("âœ… Generated domain module: {}", domain_mod_path);
            
            // Generate schema.rs file that exports the schema definition
            let schema_content = format!(
                "// {} Schema Definition\n\
                // Generated by TAO Ent Framework - DO NOT EDIT\n\n\
                use crate::framework::{{FieldDefinition, EdgeDefinition, EntityType}};\n\n\
                /// Get schema definition for {}\n\
                pub fn get_schema() -> (Vec<FieldDefinition>, Vec<EdgeDefinition>) {{\n\
                    // TODO: Export actual schema from registry\n\
                    // This should return the fields and edges for this entity\n\
                    (vec![], vec![])\n\
                }}\n\n\
                /// Entity type constant\n\
                pub const ENTITY_TYPE: EntityType = EntityType::{};\n",
                struct_name, struct_name, format!("{:?}", entity_type)
            );
            
            let schema_path = format!("src/domains/{}/schema.rs", domain_name);
            fs::write(&schema_path, schema_content)
                .map_err(|e| format!("Failed to write schema file {}: {}", schema_path, e))?;
            
            println!("âœ… Generated schema module: {}", schema_path);
        }
        
        // Generate main domains/mod.rs
        let mut domains_mod_content = String::from(
            "// Domains Module - Domain-Driven Entity Organization\n\
            // Generated by TAO Ent Framework - DO NOT EDIT\n\n\
            // Core TAO types\n\
            pub mod tao_core;\n\
            pub use tao_core::*;\n\n"
        );
        
        // Add each domain module
        for entity_type in self.registry.get_entity_types() {
            let domain_name = self.entity_domain_name(entity_type);
            let struct_name = self.entity_struct_name(entity_type);
            
            domains_mod_content.push_str(&format!(
                "// {} domain\n\
                pub mod {};\n\
                pub use {}::{{{}}};\n\n",
                struct_name, domain_name, domain_name, struct_name
            ));
        }
        
        // Add re-exports for convenience
        domains_mod_content.push_str(
            "// Re-export core framework types\n\
            pub use crate::framework::Ent;\n\n\
            // Re-export common types for easy access\n\
            pub use crate::error::AppResult;\n"
        );
        
        let domains_mod_path = "src/domains/mod.rs";
        fs::write(domains_mod_path, domains_mod_content)
            .map_err(|e| format!("Failed to write domains mod file: {}", e))?;
        
        println!("âœ… Generated domains module: {}", domains_mod_path);
        println!("ðŸ“ Domain-driven structure completed!");
        
        Ok(())
    }
    
}
// Unified Builder pattern generator - implements EntBuilder directly on entities
use super::utils;
use crate::framework::schema::ent_schema::{EntityType, FieldDefinition, SchemaRegistry};

pub struct BuilderGenerator<'a> {
    _registry: &'a SchemaRegistry,
}

impl<'a> BuilderGenerator<'a> {
    pub fn new(registry: &'a SchemaRegistry) -> Self {
        Self {
            _registry: registry,
        }
    }

    /// Generate builder state struct and EntBuilder implementation for entity
    pub fn generate_builder(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
    ) -> Result<(), String> {
        let domain_name = utils::entity_domain_name(entity_type);
        let struct_name = utils::entity_struct_name(entity_type);
        let state_name = format!("{}BuilderState", struct_name);
        let builder_path = format!("src/domains/{}/builder.rs", domain_name);

        let mut builder_content = String::new();

        // Generate file header
        builder_content.push_str(&utils::generate_file_header(
            "Unified Builder pattern implementation",
            entity_type,
        ));

        // Generate imports
        builder_content.push_str(&self.generate_imports(&struct_name));

        // Generate builder state struct
        builder_content.push_str(&self.generate_builder_state_struct(&state_name, fields)?);

        // Generate fluent interface on builder state
        builder_content.push_str(&self.generate_builder_state_impl(
            entity_type,
            &struct_name,
            &state_name,
            fields,
        )?);

        // Generate EntBuilder implementation on entity
        builder_content.push_str(&self.generate_entbuilder_impl_on_entity(
            entity_type,
            &struct_name,
            &state_name,
            fields,
        )?);

        // Generate entity create() method
        builder_content.push_str(&self.generate_entity_create_method(
            &struct_name,
            &state_name,
        )?);

        // Write to file
        std::fs::write(&builder_path, builder_content)
            .map_err(|e| format!("Failed to write builder file {}: {}", builder_path, e))?;

        Ok(())
    }

    /// Generate necessary imports for builder
    fn generate_imports(&self, struct_name: &str) -> String {
        format!(
            r#"use crate::framework::entity::ent_trait::Entity;
use crate::framework::builder::ent_builder::EntBuilder;
use crate::infrastructure::tao_core::tao_core::TaoEntityBuilder;
use crate::infrastructure::tao_core::tao_core::current_time_millis;
use crate::error::AppResult;
use super::entity::{};
use crate::infrastructure::global_tao::get_global_tao;

"#,
            struct_name
        )
    }

    /// Generate builder state struct definition
    fn generate_builder_state_struct(
        &self,
        state_name: &str,
        fields: &[FieldDefinition],
    ) -> Result<String, String> {
        let mut state_struct = format!(
            "#[derive(Debug, Default)]\npub struct {} {{\n",
            state_name
        );

        // Add all fields as Option<T> (skip ID as it's generated by TAO)
        for field in fields {
            if field.name == "id" {
                continue; // Skip ID field
            }

            let rust_type = utils::field_type_to_rust(&field.field_type, false);
            state_struct.push_str(&format!("    {}: Option<{}>,\n", field.name, rust_type));
        }

        state_struct.push_str("}\n\n");
        Ok(state_struct)
    }

    /// Generate fluent interface implementation on builder state
    fn generate_builder_state_impl(
        &self,
        entity_type: &EntityType,
        struct_name: &str,
        state_name: &str,
        fields: &[FieldDefinition],
    ) -> Result<String, String> {
        let mut impl_block = format!("impl {} {{\n", state_name);

        // Generate fluent setter methods
        for field in fields {
            if field.name == "id" {
                continue; // Skip ID field
            }

            let rust_type = utils::field_type_to_rust(&field.field_type, false);
            let method_name = &field.name;

            impl_block.push_str(&format!(
                "    pub fn {}(mut self, {}: {}) -> Self {{\n",
                method_name, method_name, rust_type
            ));
            impl_block.push_str(&format!(
                "        self.{} = Some({});\n",
                method_name, method_name
            ));
            impl_block.push_str("        self\n");
            impl_block.push_str("    }\n\n");
        }

        // Generate savex() method that uses TAO
        impl_block.push_str(&self.generate_savex_method(entity_type, struct_name)?);

        impl_block.push_str("}\n\n");
        Ok(impl_block)
    }

    /// Generate savex() method on builder state
    fn generate_savex_method(
        &self,
        _entity_type: &EntityType,
        struct_name: &str,
    ) -> Result<String, String> {
        let mut savex_method = "    /// Save the entity to database via TAO\n".to_string();
        savex_method.push_str(&format!(
            "    pub async fn savex(self) -> AppResult<{}> {{\n",
            struct_name
        ));
        savex_method.push_str("        let tao = get_global_tao()?.clone();\n");
        savex_method.push_str(&format!("        tao.create_entity::<{}>(self).await\n", struct_name));
        savex_method.push_str("    }\n\n");
        Ok(savex_method)
    }

    /// Generate EntBuilder implementation on entity type
    fn generate_entbuilder_impl_on_entity(
        &self,
        entity_type: &EntityType,
        struct_name: &str,
        state_name: &str,
        fields: &[FieldDefinition],
    ) -> Result<String, String> {
        let mut impl_block = format!("impl EntBuilder for {} {{\n", struct_name);
        impl_block.push_str(&format!("    type BuilderState = {};\n\n", state_name));

        // Generate build method
        impl_block.push_str("    fn build(state: Self::BuilderState, id: i64) -> Result<Self, String> {\n");
        impl_block.push_str("        let current_time = current_time_millis();\n\n");
        
        impl_block.push_str(&format!("        Ok({} {{\n", struct_name));
        impl_block.push_str("            id,\n");

        // Generate field assignments
        for field in fields {
            if field.name == "id" {
                continue; // Already handled above
            }

            match field.name.as_str() {
                "created_time" => {
                    impl_block.push_str("            created_time: current_time,\n");
                }
                "updated_time" | "time_updated" => {
                    if field.optional {
                        impl_block.push_str("            updated_time: Some(current_time),\n");
                    } else {
                        impl_block.push_str("            updated_time: current_time,\n");
                    }
                }
                _ => {
                    if field.optional {
                        impl_block.push_str(&format!(
                            "            {}: state.{},\n",
                            field.name, field.name
                        ));
                    } else {
                        impl_block.push_str(&format!(
                            "            {}: state.{}.ok_or_else(|| 
",
                            field.name, field.name
                        ));
                        impl_block.push_str(&format!(
                            "                \"Required field '{}' not provided\".to_string()\n",
                            field.name
                        ));
                        impl_block.push_str("            )?,\n");
                    }
                }
            }
        }
        
        impl_block.push_str("        })\n");
        impl_block.push_str("    }\n\n");

        // Generate entity_type method
        impl_block.push_str("    fn entity_type() -> &'static str {\n");
        let entity_type_str = entity_type.as_str();
        impl_block.push_str(&format!("        \"{}\"\n", entity_type_str));
        impl_block.push_str("    }\n");

        impl_block.push_str("}\n\n");
        Ok(impl_block)
    }

    /// Generate create() static method for entity
    fn generate_entity_create_method(
        &self,
        struct_name: &str,
        state_name: &str,
    ) -> Result<String, String> {
        let mut create_method = format!("impl {} {{\n", struct_name);

        create_method.push_str("    /// Create a new entity builder state\n");
        create_method.push_str(&format!("    pub fn create() -> {} {{\n", state_name));
        create_method.push_str(&format!("        {}::default()\n", state_name));
        create_method.push_str("    }\n");

        create_method.push_str("}\n\n");

        Ok(create_method)
    }
}
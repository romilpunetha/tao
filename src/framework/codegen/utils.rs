// Utility functions for code generation
use crate::framework::schema::ent_schema::{EntityType, FieldType};

/// Convert entity type to domain name (e.g., EntUser -> "user")
pub fn entity_domain_name(entity_type: &EntityType) -> String {
    let type_str = entity_type.as_str();
    if type_str.starts_with("ent_") {
        type_str[4..].to_string()
    } else {
        type_str.to_string()
    }
}

/// Convert entity type to struct name (e.g., EntUser -> "EntUser")
pub fn entity_struct_name(entity_type: &EntityType) -> String {
    // Convert snake_case to PascalCase
    let type_str = entity_type.as_str();
    type_str
        .split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

/// Convert entity type to builder name (e.g., "ent_user" -> "EntUserBuilder")
pub fn entity_builder_name(entity_type: &EntityType) -> String {
    format!("{}Builder", entity_struct_name(entity_type))
}

/// Convert field type to Rust type
pub fn field_type_to_rust(field_type: &FieldType, optional: bool) -> String {
    let base_type = match field_type {
        FieldType::String => "String".to_string(),
        FieldType::Int => "i32".to_string(),
        FieldType::Int64 => "i64".to_string(),
        FieldType::Bool => "bool".to_string(),
        FieldType::Float => "f64".to_string(),
        FieldType::Bytes => "Vec<u8>".to_string(),
        FieldType::Time => "i64".to_string(), // Unix timestamp
        FieldType::UUID => "String".to_string(), // String representation
        FieldType::JSON => "String".to_string(), // JSON as string
        FieldType::Enum(_variants) => "String".to_string(), // Enum as string for simplicity
    };

    if optional {
        format!("Option<{}>", base_type)
    } else {
        base_type
    }
}

/// Convert field type to Thrift type
pub fn field_type_to_thrift(field_type: &FieldType) -> String {
    match field_type {
        FieldType::String => "string".to_string(),
        FieldType::Int => "i32".to_string(),
        FieldType::Int64 => "i64".to_string(),
        FieldType::Bool => "bool".to_string(),
        FieldType::Float => "double".to_string(),
        FieldType::Bytes => "binary".to_string(),
        FieldType::Time => "i64".to_string(), // Unix timestamp as i64
        FieldType::UUID => "string".to_string(), // UUID as string
        FieldType::JSON => "string".to_string(), // JSON as string
        FieldType::Enum(_variants) => "string".to_string(), // Enum as string
    }
}

/// Generate field number for Thrift (1-based indexing)
pub fn generate_field_number(index: usize) -> i16 {
    (index + 1) as i16
}

/// Check if field is required (non-optional)
pub fn is_required_field(optional: bool) -> &'static str {
    if optional {
        "optional"
    } else {
        "required"
    }
}

/// Convert snake_case to camelCase
pub fn snake_to_camel(s: &str) -> String {
    let mut result = String::new();
    let mut chars = s.chars();

    if let Some(first) = chars.next() {
        result.push(first.to_lowercase().next().unwrap());
    }

    let mut capitalize_next = false;
    for c in chars {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_uppercase().next().unwrap());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

/// Generate file header comment
pub fn generate_file_header(file_type: &str, entity_type: &EntityType) -> String {
    format!(
        "// Generated {} for {}\n// Generated by TAO Ent Framework - DO NOT EDIT\n// Regenerate with: cargo run --bin entc generate\n\n",
        file_type, entity_struct_name(entity_type)
    )
}

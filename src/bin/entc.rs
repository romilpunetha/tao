// entc - Ent Code Generator CLI
// Equivalent to Meta's entc command for generating entity code from schemas

use std::env;
use std::fs;
use std::path::Path;
use tao_database::{
    ent_codegen::EntCodeGenerator,
    schemas::{create_schema_registry, validate_schemas},
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();
    
    if args.len() < 2 {
        eprintln!("Usage: entc <command>");
        eprintln!("Commands:");
        eprintln!("  generate  - Generate entity code from schemas");
        eprintln!("  validate  - Validate schema definitions");
        return Ok(());
    }
    
    match args[1].as_str() {
        "generate" => generate_code()?,
        "validate" => validate_schemas_cmd()?,
        _ => {
            eprintln!("Unknown command: {}", args[1]);
            eprintln!("Use 'generate' or 'validate'");
        }
    }
    
    Ok(())
}

fn generate_code() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 Ent Code Generator - Generating entity code from schemas...");
    
    // Validate schemas first
    if let Err(errors) = validate_schemas() {
        eprintln!("❌ Schema validation failed:");
        for error in errors {
            eprintln!("  - {}", error);
        }
        return Err("Schema validation failed".into());
    }
    
    println!("✅ Schema validation passed");
    
    // Create schema registry and code generator
    let registry = create_schema_registry();
    let generator = EntCodeGenerator::new(registry);
    
    // Generate code for all entities
    match generator.generate_all() {
        Ok(generated_code) => {
            println!("📝 Generated code for {} entities:", generated_code.len());
            
            // Create output directory
            let output_dir = Path::new("src/generated");
            if !output_dir.exists() {
                fs::create_dir_all(output_dir)?;
            }
            
            // Write generated code to files
            for (entity_type, code) in generated_code {
                let filename = format!("{}.rs", entity_type.as_str());
                let filepath = output_dir.join(filename);
                
                fs::write(&filepath, code)?;
                println!("  ✓ Generated {}", filepath.display());
            }
            
            // Generate mod.rs for the generated module
            let mod_content = generate_mod_file();
            fs::write(output_dir.join("mod.rs"), mod_content)?;
            println!("  ✓ Generated {}", output_dir.join("mod.rs").display());
            
            println!("🎉 Code generation completed successfully!");
            println!("📁 Generated files in: {}", output_dir.display());
        },
        Err(error) => {
            eprintln!("❌ Code generation failed: {}", error);
            return Err(error.into());
        }
    }
    
    Ok(())
}

fn validate_schemas_cmd() -> Result<(), Box<dyn std::error::Error>> {
    println!("🔍 Validating schema definitions...");
    
    match validate_schemas() {
        Ok(()) => {
            println!("✅ All schemas are valid!");
        },
        Err(errors) => {
            eprintln!("❌ Schema validation failed:");
            for error in errors {
                eprintln!("  - {}", error);
            }
            return Err("Schema validation failed".into());
        }
    }
    
    Ok(())
}

fn generate_mod_file() -> String {
    r#"// Generated module file - DO NOT EDIT
// This file is automatically generated by entc

pub mod ent_user;
pub mod ent_post;
pub mod ent_comment;
pub mod ent_group;
pub mod ent_page;
pub mod ent_event;

// Re-export generated entities
pub use ent_user::EntUser;
pub use ent_post::EntPost;
pub use ent_comment::EntComment;
pub use ent_group::EntGroup;
pub use ent_page::EntPage;
pub use ent_event::EntEvent;
"#.to_string()
}
// Ent Code Generator - Generates Rust entity code from schema definitions
// Equivalent to Meta's entc (ent codegen) for automatic code generation

use std::collections::HashMap;
use crate::ent_schema::{
    FieldDefinition, EdgeDefinition, EdgeType, EdgeCardinality, 
    FieldType, SchemaRegistry
};
use crate::models::EntityType;

/// Code generator for entity schemas
pub struct EntCodeGenerator {
    registry: SchemaRegistry,
}

impl EntCodeGenerator {
    pub fn new(registry: SchemaRegistry) -> Self {
        Self { registry }
    }
    
    /// Generate complete entity code for all registered schemas
    pub fn generate_all(&self) -> Result<HashMap<EntityType, String>, String> {
        let mut generated_code = HashMap::new();
        
        // Validate schemas first
        self.registry.validate().map_err(|errors| {
            format!("Schema validation failed:\n{}", errors.join("\n"))
        })?;
        
        // Generate code for each entity
        for entity_type in [
            EntityType::EntUser,
            EntityType::EntPost,
            EntityType::EntComment,
            EntityType::EntGroup,
            EntityType::EntPage,
            EntityType::EntEvent,
        ] {
            if let (Some(fields), Some(edges)) = (
                self.registry.get_fields(&entity_type),
                self.registry.get_edges(&entity_type),
            ) {
                let code = self.generate_entity_code(&entity_type, fields, edges)?;
                generated_code.insert(entity_type, code);
            }
        }
        
        Ok(generated_code)
    }
    
    /// Generate entity struct and implementation
    fn generate_entity_code(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
        edges: &[EdgeDefinition],
    ) -> Result<String, String> {
        let mut code = String::new();
        
        // Generate imports
        code.push_str(&self.generate_imports());
        
        // Generate entity struct
        code.push_str(&self.generate_entity_struct(entity_type, fields)?);
        
        // Generate field validation
        code.push_str(&self.generate_field_validation(entity_type, fields)?);
        
        // Generate edge helper methods
        code.push_str(&self.generate_edge_methods(entity_type, edges)?);
        
        // Generate Entity trait implementation
        code.push_str(&self.generate_entity_trait_impl(entity_type)?);
        
        // Generate TaoEntity trait implementation
        code.push_str(&self.generate_tao_entity_trait_impl(entity_type)?);
        
        Ok(code)
    }
    
    fn generate_imports(&self) -> String {
        r#"// Generated by Ent Code Generator - DO NOT EDIT
use serde::{Deserialize, Serialize};
use thrift::protocol::{TInputProtocol, TOutputProtocol, TSerializable, TFieldIdentifier, TStructIdentifier, TType};
use thrift::protocol::{field_id, verify_required_field_exists};
use crate::{
    entities::{Entity, TaoEntity},
    models::EntityType,
    tao_interface::TaoInterface,
    error::AppResult,
};
use anyhow::Result;

"#.to_string()
    }
    
    fn generate_entity_struct(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("#[derive(Debug, Clone, Serialize, Deserialize, Eq, Hash, PartialEq)]\npub struct {} {{\n", struct_name);
        
        // Generate fields
        for field in fields {
            let rust_type = self.field_type_to_rust(&field.field_type, field.optional);
            code.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
        }
        
        code.push_str("}\n\n");
        
        // Generate constructor
        code.push_str(&self.generate_constructor(entity_type, fields)?);
        
        // Generate Thrift serialization
        code.push_str(&self.generate_thrift_serialization(entity_type, fields)?);
        
        Ok(code)
    }
    
    fn generate_constructor(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        code.push_str("    pub fn new(\n");
        
        // Required fields as parameters
        let required_fields: Vec<_> = fields.iter().filter(|f| !f.optional).collect();
        for field in &required_fields {
            let rust_type = self.field_type_to_rust(&field.field_type, false);
            code.push_str(&format!("        {}: {},\n", field.name, rust_type));
        }
        
        code.push_str(&format!("    ) -> {} {{\n", struct_name));
        code.push_str(&format!("        {} {{\n", struct_name));
        
        // Set required fields
        for field in &required_fields {
            code.push_str(&format!("            {},\n", field.name));
        }
        
        // Set optional fields to defaults
        for field in fields.iter().filter(|f| f.optional) {
            if let Some(default) = &field.default {
                let default_value = self.default_to_rust(default);
                code.push_str(&format!("            {}: {},\n", field.name, default_value));
            } else {
                code.push_str(&format!("            {}: None,\n", field.name));
            }
        }
        
        code.push_str("        }\n    }\n");
        
        // Generate builder methods for optional fields
        for field in fields.iter().filter(|f| f.optional) {
            let rust_type = self.field_type_to_rust(&field.field_type, false);
            code.push_str(&format!(
                "    \n    pub fn with_{}(mut self, {}: {}) -> Self {{\n",
                field.name, field.name, rust_type
            ));
            code.push_str(&format!("        self.{} = Some({});\n", field.name, field.name));
            code.push_str("        self\n    }\n");
        }
        
        code.push_str("}\n\n");
        Ok(code)
    }
    
    fn generate_field_validation(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        code.push_str("    /// Validate entity fields according to schema constraints\n");
        code.push_str("    pub fn validate(&self) -> Result<(), Vec<String>> {\n");
        code.push_str("        let mut errors = Vec::new();\n\n");
        
        for field in fields {
            // Generate validation for each field based on validators
            for validator in &field.validators {
                let validation_code = match validator {
                    crate::ent_schema::FieldValidator::MinLength(min) => {
                        if field.optional {
                            format!(
                                "        if let Some(ref val) = self.{} {{\n            if val.len() < {} {{\n                errors.push(format!(\"{} must be at least {} characters\"));\n            }}\n        }}\n",
                                field.name, min, field.name, min
                            )
                        } else {
                            format!(
                                "        if self.{}.len() < {} {{\n            errors.push(format!(\"{} must be at least {} characters\"));\n        }}\n",
                                field.name, min, field.name, min
                            )
                        }
                    },
                    crate::ent_schema::FieldValidator::MaxLength(max) => {
                        if field.optional {
                            format!(
                                "        if let Some(ref val) = self.{} {{\n            if val.len() > {} {{\n                errors.push(format!(\"{} must be at most {} characters\"));\n            }}\n        }}\n",
                                field.name, max, field.name, max
                            )
                        } else {
                            format!(
                                "        if self.{}.len() > {} {{\n            errors.push(format!(\"{} must be at most {} characters\"));\n        }}\n",
                                field.name, max, field.name, max
                            )
                        }
                    },
                    crate::ent_schema::FieldValidator::Pattern(pattern) => {
                        format!(
                            "        // TODO: Implement regex validation for pattern: {}\n",
                            pattern
                        )
                    },
                    crate::ent_schema::FieldValidator::Range(min, max) => {
                        format!(
                            "        if self.{} < {} || self.{} > {} {{\n            errors.push(format!(\"{} must be between {} and {}\"));\n        }}\n",
                            field.name, min, field.name, max, field.name, min, max
                        )
                    },
                    crate::ent_schema::FieldValidator::Custom(func) => {
                        format!("        // TODO: Call custom validator: {}\n", func)
                    },
                };
                code.push_str(&validation_code);
            }
        }
        
        code.push_str("        \n        if errors.is_empty() {\n            Ok(())\n        } else {\n            Err(errors)\n        }\n    }\n");
        code.push_str("}\n\n");
        Ok(code)
    }
    
    fn generate_edge_methods(
        &self,
        entity_type: &EntityType,
        edges: &[EdgeDefinition],
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl {} {{\n", struct_name);
        
        for edge in edges {
            let method_name = match edge.edge_type {
                EdgeType::To => format!("get_{}", edge.name),
                EdgeType::From => format!("get_{}", edge.name),
            };
            
            let target_type = format!("crate::generated::{}", self.entity_struct_name(&edge.target_entity));
            let return_type = match edge.cardinality {
                EdgeCardinality::OneToOne => {
                    if edge.required {
                        format!("({}, {})", "i64", target_type)
                    } else {
                        format!("Option<({}, {})>", "i64", target_type)
                    }
                },
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    format!("Vec<({}, {})>", "i64", target_type)
                },
                EdgeCardinality::ManyToOne => {
                    format!("Option<({}, {})>", "i64", target_type)
                },
            };
            
            // Map edge names to association types
            let assoc_type = self.edge_to_association_type(&edge.name);
            let target_entity_type_str = edge.target_entity.as_str();
            
            code.push_str(&format!(
                "    /// Get {} entities via {} edge\n",
                self.entity_struct_name(&edge.target_entity),
                edge.name
            ));
            code.push_str(&format!(
                "    pub async fn {}(tao: &TaoInterface, entity_id: i64) -> Result<{}> {{\n",
                method_name, return_type
            ));
            
            match edge.cardinality {
                EdgeCardinality::OneToMany | EdgeCardinality::ManyToMany => {
                    code.push_str(&format!(
                        "        let entities = tao.get_associated_entities::<crate::generated::{}>(entity_id, {}, \"{}\", None).await?;\n",
                        self.entity_struct_name(&edge.target_entity),
                        assoc_type,
                        target_entity_type_str
                    ));
                    code.push_str("        Ok(entities)\n");
                },
                EdgeCardinality::OneToOne | EdgeCardinality::ManyToOne => {
                    code.push_str(&format!(
                        "        let entities = tao.get_associated_entities::<crate::generated::{}>(entity_id, {}, \"{}\", Some(1)).await?;\n",
                        self.entity_struct_name(&edge.target_entity),
                        assoc_type,
                        target_entity_type_str
                    ));
                    if edge.required {
                        code.push_str("        entities.into_iter().next().ok_or_else(|| anyhow::anyhow!(\"Required relationship not found\"))\n");
                    } else {
                        code.push_str("        Ok(entities.into_iter().next())\n");
                    }
                },
            }
            
            code.push_str("    }\n\n");
        }
        
        code.push_str("}\n\n");
        Ok(code)
    }

    fn edge_to_association_type(&self, edge_name: &str) -> String {
        // Map edge names to AssociationType enum variants
        match edge_name {
            "friends" => "crate::models::AssociationType::Friendship".to_string(),
            "following" => "crate::models::AssociationType::Follow".to_string(),
            "followers" => "crate::models::AssociationType::FollowedBy".to_string(),
            "posts" => "crate::models::AssociationType::PostAuthor".to_string(),
            "liked_posts" => "crate::models::AssociationType::Like".to_string(),
            "groups" => "crate::models::AssociationType::Membership".to_string(),
            "followed_pages" => "crate::models::AssociationType::Follow".to_string(),
            "attending_events" => "crate::models::AssociationType::EventAttendance".to_string(),
            "members" => "crate::models::AssociationType::Membership".to_string(),
            "author" => "crate::models::AssociationType::PostAuthor".to_string(),
            "post" => "crate::models::AssociationType::CommentParent".to_string(),
            "comments" => "crate::models::AssociationType::Comments".to_string(),
            "liked_by" => "crate::models::AssociationType::LikedBy".to_string(),
            "mentioned_users" => "crate::models::AssociationType::MentionedUsers".to_string(),
            "appears_on_pages" => "crate::models::AssociationType::AppearsOnPages".to_string(),
            "shared_in_groups" => "crate::models::AssociationType::SharedInGroups".to_string(),
            "related_events" => "crate::models::AssociationType::RelatedEvents".to_string(),
            "attendees" => "crate::models::AssociationType::Attendees".to_string(),
            "related_posts" => "crate::models::AssociationType::RelatedPosts".to_string(),
            _ => format!("crate::models::AssociationType::{}", edge_name.to_uppercase()),
        }
    }
    
    fn generate_entity_trait_impl(&self, entity_type: &EntityType) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let code = format!(
            r#"impl Entity for {} {{
    fn entity_type() -> EntityType {{
        EntityType::{:?}
    }}
}}

"#,
            struct_name, entity_type
        );
        
        Ok(code)
    }
    
    fn generate_tao_entity_trait_impl(&self, entity_type: &EntityType) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        
        let code = format!(
            r#"impl TaoEntity for {} {{}}

"#,
            struct_name
        );
        
        Ok(code)
    }
    
    fn entity_struct_name(&self, entity_type: &EntityType) -> String {
        match entity_type {
            EntityType::EntUser => "EntUser".to_string(),
            EntityType::EntPost => "EntPost".to_string(),
            EntityType::EntComment => "EntComment".to_string(),
            EntityType::EntGroup => "EntGroup".to_string(),
            EntityType::EntPage => "EntPage".to_string(),
            EntityType::EntEvent => "EntEvent".to_string(),
        }
    }
    
    fn field_type_to_rust(&self, field_type: &FieldType, optional: bool) -> String {
        let base_type = match field_type {
            FieldType::String => "String".to_string(),
            FieldType::Int => "i32".to_string(),
            FieldType::Int64 => "i64".to_string(),
            FieldType::Float => "f64".to_string(),
            FieldType::Bool => "bool".to_string(),
            FieldType::Time => "i64".to_string(), // Unix timestamp
            FieldType::UUID => "String".to_string(), // UUID as string
            FieldType::Bytes => "Vec<u8>".to_string(),
            FieldType::JSON => "serde_json::Value".to_string(),
            FieldType::Enum(_variants) => {
                // TODO: Generate enum types
                "String".to_string()
            },
        };
        
        if optional {
            format!("Option<{}>", base_type)
        } else {
            base_type
        }
    }
    
    fn default_to_rust(&self, default: &crate::ent_schema::FieldDefault) -> String {
        match default {
            crate::ent_schema::FieldDefault::String(s) => format!("Some(\"{}\".to_string())", s),
            crate::ent_schema::FieldDefault::Int(i) => format!("Some({})", i),
            crate::ent_schema::FieldDefault::Int64(i) => format!("Some({})", i),
            crate::ent_schema::FieldDefault::Float(f) => format!("Some({})", f),
            crate::ent_schema::FieldDefault::Bool(b) => format!("Some({})", b),
            crate::ent_schema::FieldDefault::Function(func) => {
                format!("Some({}())", func) // TODO: Call dynamic function
            },
        }
    }
    
    fn generate_thrift_serialization(
        &self,
        entity_type: &EntityType,
        fields: &[FieldDefinition],
    ) -> Result<String, String> {
        let struct_name = self.entity_struct_name(entity_type);
        let mut code = format!("impl TSerializable for {} {{\n", struct_name);
        
        // Generate read_from_in_protocol
        code.push_str("    fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Self> {\n");
        code.push_str("        i_prot.read_struct_begin()?;\n");
        
        // Declare field variables
        for (index, field) in fields.iter().enumerate() {
            let field_index = index + 1;
            let base_type = match &field.field_type {
                FieldType::JSON => "String".to_string(), // JSON stored as string during parsing
                _ => {
                    let rust_type = self.field_type_to_rust(&field.field_type, true);
                    rust_type.strip_prefix("Option<").unwrap_or(&rust_type).strip_suffix(">").unwrap_or(&rust_type).to_string()
                }
            };
            code.push_str(&format!("        let mut f_{}: Option<{}> = None;\n", field_index, base_type));
        }
        
        code.push_str("        loop {\n");
        code.push_str("            let field_ident = i_prot.read_field_begin()?;\n");
        code.push_str("            if field_ident.field_type == TType::Stop {\n");
        code.push_str("                break;\n");
        code.push_str("            }\n");
        code.push_str("            let field_id = field_id(&field_ident)?;\n");
        code.push_str("            match field_id {\n");
        
        // Generate field parsing
        for (index, field) in fields.iter().enumerate() {
            let field_index = index + 1;
            let read_method = self.thrift_read_method(&field.field_type);
            code.push_str(&format!("                {} => {{\n", field_index));
            code.push_str(&format!("                    let val = i_prot.{}()?;\n", read_method));
            code.push_str(&format!("                    f_{} = Some(val);\n", field_index));
            code.push_str("                },\n");
        }
        
        code.push_str("                _ => {\n");
        code.push_str("                    i_prot.skip(field_ident.field_type)?;\n");
        code.push_str("                },\n");
        code.push_str("            };\n");
        code.push_str("            i_prot.read_field_end()?;\n");
        code.push_str("        }\n");
        code.push_str("        i_prot.read_struct_end()?;\n");
        
        // Verify required fields
        for (index, field) in fields.iter().enumerate().filter(|(_, f)| !f.optional) {
            let field_index = index + 1;
            code.push_str(&format!(
                "        verify_required_field_exists(\"{}.{}\", &f_{})?;\n",
                struct_name, field.name, field_index
            ));
        }
        
        // Construct entity
        code.push_str(&format!("        let ret = {} {{\n", struct_name));
        for (index, field) in fields.iter().enumerate() {
            let field_index = index + 1;
            if field.optional {
                match &field.field_type {
                    FieldType::JSON => {
                        code.push_str(&format!(
                            "            {}: f_{}.and_then(|s| serde_json::from_str(&s).ok()),\n", 
                            field.name, field_index
                        ));
                    },
                    _ => {
                        code.push_str(&format!("            {}: f_{},\n", field.name, field_index));
                    }
                }
            } else {
                match &field.field_type {
                    FieldType::JSON => {
                        code.push_str(&format!(
                            "            {}: f_{}.and_then(|s| serde_json::from_str(&s).ok()).expect(\"auto-generated code should have checked for presence of required fields\"),\n",
                            field.name, field_index
                        ));
                    },
                    _ => {
                        code.push_str(&format!(
                            "            {}: f_{}.expect(\"auto-generated code should have checked for presence of required fields\"),\n",
                            field.name, field_index
                        ));
                    }
                }
            }
        }
        code.push_str("        };\n");
        code.push_str("        Ok(ret)\n");
        code.push_str("    }\n\n");
        
        // Generate write_to_out_protocol
        code.push_str("    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {\n");
        code.push_str(&format!("        let struct_ident = TStructIdentifier::new(\"{}\");\n", struct_name));
        code.push_str("        o_prot.write_struct_begin(&struct_ident)?;\n");
        
        // Write fields
        for (index, field) in fields.iter().enumerate() {
            let field_index = index + 1;
            let thrift_type = self.thrift_type(&field.field_type);
            let write_method = self.thrift_write_method(&field.field_type);
            
            if field.optional {
                code.push_str(&format!("        if let Some(ref fld_var) = self.{} {{\n", field.name));
                code.push_str(&format!(
                    "            o_prot.write_field_begin(&TFieldIdentifier::new(\"{}\", {}, {}))?;\n",
                    field.name, thrift_type, field_index
                ));
                match field.field_type {
                    FieldType::String | FieldType::UUID | FieldType::Enum(_) => {
                        code.push_str("            o_prot.write_string(fld_var)?;\n");
                    },
                    FieldType::JSON => {
                        code.push_str("            let json_str = serde_json::to_string(fld_var).unwrap_or_default();\n");
                        code.push_str("            o_prot.write_string(&json_str)?;\n");
                    },
                    _ => {
                        code.push_str(&format!("            o_prot.{}(*fld_var)?;\n", write_method));
                    }
                }
                code.push_str("            o_prot.write_field_end()?;\n");
                code.push_str("        }\n");
            } else {
                code.push_str(&format!(
                    "        o_prot.write_field_begin(&TFieldIdentifier::new(\"{}\", {}, {}))?;\n",
                    field.name, thrift_type, field_index
                ));
                match field.field_type {
                    FieldType::String | FieldType::UUID | FieldType::Enum(_) => {
                        code.push_str(&format!("        o_prot.write_string(&self.{})?;\n", field.name));
                    },
                    FieldType::JSON => {
                        code.push_str(&format!("        let json_str = serde_json::to_string(&self.{}).unwrap_or_default();\n", field.name));
                        code.push_str("        o_prot.write_string(&json_str)?;\n");
                    },
                    _ => {
                        code.push_str(&format!("        o_prot.{}(self.{})?;\n", write_method, field.name));
                    }
                }
                code.push_str("        o_prot.write_field_end()?;\n");
            }
        }
        
        code.push_str("        o_prot.write_field_stop()?;\n");
        code.push_str("        o_prot.write_struct_end()\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
        
        Ok(code)
    }
    
    fn thrift_read_method(&self, field_type: &FieldType) -> String {
        match field_type {
            FieldType::String => "read_string".to_string(),
            FieldType::Int => "read_i32".to_string(),
            FieldType::Int64 | FieldType::Time => "read_i64".to_string(),
            FieldType::Float => "read_double".to_string(),
            FieldType::Bool => "read_bool".to_string(),
            FieldType::UUID => "read_string".to_string(),
            FieldType::Bytes => "read_bytes".to_string(),
            FieldType::JSON => "read_string".to_string(), // JSON stored as string
            FieldType::Enum(_) => "read_string".to_string(), // Enums as strings for now
        }
    }
    
    fn thrift_write_method(&self, field_type: &FieldType) -> String {
        match field_type {
            FieldType::String => "write_string".to_string(),
            FieldType::Int => "write_i32".to_string(),
            FieldType::Int64 | FieldType::Time => "write_i64".to_string(),
            FieldType::Float => "write_double".to_string(),
            FieldType::Bool => "write_bool".to_string(),
            FieldType::UUID => "write_string".to_string(),
            FieldType::Bytes => "write_bytes".to_string(),
            FieldType::JSON => "write_string".to_string(), // JSON stored as string
            FieldType::Enum(_) => "write_string".to_string(), // Enums as strings for now
        }
    }
    
    fn thrift_type(&self, field_type: &FieldType) -> String {
        match field_type {
            FieldType::String | FieldType::UUID | FieldType::JSON | FieldType::Enum(_) => "TType::String".to_string(),
            FieldType::Int => "TType::I32".to_string(),
            FieldType::Int64 | FieldType::Time => "TType::I64".to_string(),
            FieldType::Float => "TType::Double".to_string(),
            FieldType::Bool => "TType::Bool".to_string(),
            FieldType::Bytes => "TType::String".to_string(), // Bytes as base64 string
        }
    }
}
// Generated by Ent Code Generator - DO NOT EDIT
use serde::{Deserialize, Serialize};
use thrift::protocol::{TInputProtocol, TOutputProtocol, TSerializable, TFieldIdentifier, TStructIdentifier, TType};
use thrift::protocol::{field_id, verify_required_field_exists};
use crate::{
    entities::{Entity, TaoEntity},
    models::EntityType,
    tao_interface::TaoInterface,
    error::AppResult,
};
use anyhow::Result;

#[derive(Debug, Clone, Serialize, Deserialize, Eq, Hash, PartialEq)]
pub struct EntUser {
    pub username: String,
    pub email: String,
    pub created_time: i64,
    pub full_name: Option<String>,
    pub bio: Option<String>,
    pub profile_picture_url: Option<String>,
    pub last_active_time: Option<i64>,
    pub is_verified: bool,
    pub location: Option<String>,
    pub privacy_settings: Option<serde_json::Value>,
}

impl EntUser {
    pub fn new(
        username: String,
        email: String,
        created_time: i64,
        is_verified: bool,
    ) -> EntUser {
        EntUser {
            username,
            email,
            created_time,
            is_verified,
            full_name: None,
            bio: None,
            profile_picture_url: None,
            last_active_time: None,
            location: None,
            privacy_settings: None,
        }
    }
    
    pub fn with_full_name(mut self, full_name: String) -> Self {
        self.full_name = Some(full_name);
        self
    }
    
    pub fn with_bio(mut self, bio: String) -> Self {
        self.bio = Some(bio);
        self
    }
    
    pub fn with_profile_picture_url(mut self, profile_picture_url: String) -> Self {
        self.profile_picture_url = Some(profile_picture_url);
        self
    }
    
    pub fn with_last_active_time(mut self, last_active_time: i64) -> Self {
        self.last_active_time = Some(last_active_time);
        self
    }
    
    pub fn with_location(mut self, location: String) -> Self {
        self.location = Some(location);
        self
    }
    
    pub fn with_privacy_settings(mut self, privacy_settings: serde_json::Value) -> Self {
        self.privacy_settings = Some(privacy_settings);
        self
    }
}

impl TSerializable for EntUser {
    fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Self> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<String> = None;
        let mut f_2: Option<String> = None;
        let mut f_3: Option<i64> = None;
        let mut f_4: Option<String> = None;
        let mut f_5: Option<String> = None;
        let mut f_6: Option<String> = None;
        let mut f_7: Option<i64> = None;
        let mut f_8: Option<bool> = None;
        let mut f_9: Option<String> = None;
        let mut f_10: Option<String> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = i_prot.read_string()?;
                    f_1 = Some(val);
                },
                2 => {
                    let val = i_prot.read_string()?;
                    f_2 = Some(val);
                },
                3 => {
                    let val = i_prot.read_i64()?;
                    f_3 = Some(val);
                },
                4 => {
                    let val = i_prot.read_string()?;
                    f_4 = Some(val);
                },
                5 => {
                    let val = i_prot.read_string()?;
                    f_5 = Some(val);
                },
                6 => {
                    let val = i_prot.read_string()?;
                    f_6 = Some(val);
                },
                7 => {
                    let val = i_prot.read_i64()?;
                    f_7 = Some(val);
                },
                8 => {
                    let val = i_prot.read_bool()?;
                    f_8 = Some(val);
                },
                9 => {
                    let val = i_prot.read_string()?;
                    f_9 = Some(val);
                },
                10 => {
                    let val = i_prot.read_string()?;
                    f_10 = Some(val);
                },
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                },
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("EntUser.username", &f_1)?;
        verify_required_field_exists("EntUser.email", &f_2)?;
        verify_required_field_exists("EntUser.created_time", &f_3)?;
        verify_required_field_exists("EntUser.is_verified", &f_8)?;
        let ret = EntUser {
            username: f_1.expect("auto-generated code should have checked for presence of required fields"),
            email: f_2.expect("auto-generated code should have checked for presence of required fields"),
            created_time: f_3.expect("auto-generated code should have checked for presence of required fields"),
            full_name: f_4,
            bio: f_5,
            profile_picture_url: f_6,
            last_active_time: f_7,
            is_verified: f_8.expect("auto-generated code should have checked for presence of required fields"),
            location: f_9,
            privacy_settings: f_10.and_then(|s| serde_json::from_str(&s).ok()),
        };
        Ok(ret)
    }

    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("EntUser");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 1))?;
        o_prot.write_string(&self.username)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 2))?;
        o_prot.write_string(&self.email)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 3))?;
        o_prot.write_i64(self.created_time)?;
        o_prot.write_field_end()?;
        if let Some(ref fld_var) = self.full_name {
            o_prot.write_field_begin(&TFieldIdentifier::new("full_name", TType::String, 4))?;
            o_prot.write_string(fld_var)?;
            o_prot.write_field_end()?;
        }
        if let Some(ref fld_var) = self.bio {
            o_prot.write_field_begin(&TFieldIdentifier::new("bio", TType::String, 5))?;
            o_prot.write_string(fld_var)?;
            o_prot.write_field_end()?;
        }
        if let Some(ref fld_var) = self.profile_picture_url {
            o_prot.write_field_begin(&TFieldIdentifier::new("profile_picture_url", TType::String, 6))?;
            o_prot.write_string(fld_var)?;
            o_prot.write_field_end()?;
        }
        if let Some(ref fld_var) = self.last_active_time {
            o_prot.write_field_begin(&TFieldIdentifier::new("last_active_time", TType::I64, 7))?;
            o_prot.write_i64(*fld_var)?;
            o_prot.write_field_end()?;
        }
        o_prot.write_field_begin(&TFieldIdentifier::new("is_verified", TType::Bool, 8))?;
        o_prot.write_bool(self.is_verified)?;
        o_prot.write_field_end()?;
        if let Some(ref fld_var) = self.location {
            o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::String, 9))?;
            o_prot.write_string(fld_var)?;
            o_prot.write_field_end()?;
        }
        if let Some(ref fld_var) = self.privacy_settings {
            o_prot.write_field_begin(&TFieldIdentifier::new("privacy_settings", TType::String, 10))?;
            let json_str = serde_json::to_string(fld_var).unwrap_or_default();
            o_prot.write_string(&json_str)?;
            o_prot.write_field_end()?;
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

impl EntUser {
    /// Validate entity fields according to schema constraints
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        if self.username.len() < 3 {
            errors.push(format!("username must be at least 3 characters"));
        }
        if self.username.len() > 30 {
            errors.push(format!("username must be at most 30 characters"));
        }
        // TODO: Implement regex validation for pattern: ^[a-zA-Z0-9_]+$
        // TODO: Implement regex validation for pattern: ^[^\s@]+@[^\s@]+\.[^\s@]+$
        if self.full_name.len() > 100 {
            errors.push(format!("full_name must be at most 100 characters"));
        }
        if self.bio.len() > 500 {
            errors.push(format!("bio must be at most 500 characters"));
        }
        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

impl EntUser {
    /// Get EntUser entities via friends edge
    pub async fn get_friends(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntUser)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntUser>(entity_id, crate::models::AssociationType::Friendship, "ent_user", None).await?;
        Ok(entities)
    }

    /// Get EntUser entities via following edge
    pub async fn get_following(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntUser)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntUser>(entity_id, crate::models::AssociationType::Follow, "ent_user", None).await?;
        Ok(entities)
    }

    /// Get EntUser entities via followers edge
    pub async fn get_followers(tao: &TaoInterface, entity_id: i64) -> Result<Option<(i64, crate::generated::EntUser)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntUser>(entity_id, crate::models::AssociationType::FollowedBy, "ent_user", Some(1)).await?;
        Ok(entities.into_iter().next())
    }

    /// Get EntPost entities via posts edge
    pub async fn get_posts(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntPost)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntPost>(entity_id, crate::models::AssociationType::PostAuthor, "ent_post", None).await?;
        Ok(entities)
    }

    /// Get EntPost entities via liked_posts edge
    pub async fn get_liked_posts(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntPost)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntPost>(entity_id, crate::models::AssociationType::Like, "ent_post", None).await?;
        Ok(entities)
    }

    /// Get EntGroup entities via groups edge
    pub async fn get_groups(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntGroup)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntGroup>(entity_id, crate::models::AssociationType::Membership, "ent_group", None).await?;
        Ok(entities)
    }

    /// Get EntPage entities via followed_pages edge
    pub async fn get_followed_pages(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntPage)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntPage>(entity_id, crate::models::AssociationType::Follow, "ent_page", None).await?;
        Ok(entities)
    }

    /// Get EntEvent entities via attending_events edge
    pub async fn get_attending_events(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntEvent)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntEvent>(entity_id, crate::models::AssociationType::EventAttendance, "ent_event", None).await?;
        Ok(entities)
    }

}

impl Entity for EntUser {
    fn entity_type() -> EntityType {
        EntityType::EntUser
    }
}

impl TaoEntity for EntUser {}


// Generated by Ent Code Generator - DO NOT EDIT
use serde::{Deserialize, Serialize};
use thrift::protocol::{TInputProtocol, TOutputProtocol, TSerializable, TFieldIdentifier, TStructIdentifier, TType};
use thrift::protocol::{field_id, verify_required_field_exists};
use crate::{
    entities::{Entity, TaoEntity},
    models::EntityType,
    tao_interface::TaoInterface,
    error::AppResult,
};
use anyhow::Result;

#[derive(Debug, Clone, Serialize, Deserialize, Eq, Hash, PartialEq)]
pub struct EntComment {
    pub author_id: i64,
    pub post_id: i64,
    pub content: String,
    pub created_time: i64,
}

impl EntComment {
    pub fn new(
        author_id: i64,
        post_id: i64,
        content: String,
        created_time: i64,
    ) -> EntComment {
        EntComment {
            author_id,
            post_id,
            content,
            created_time,
        }
    }
}

impl TSerializable for EntComment {
    fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Self> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<i64> = None;
        let mut f_2: Option<i64> = None;
        let mut f_3: Option<String> = None;
        let mut f_4: Option<i64> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = i_prot.read_i64()?;
                    f_1 = Some(val);
                },
                2 => {
                    let val = i_prot.read_i64()?;
                    f_2 = Some(val);
                },
                3 => {
                    let val = i_prot.read_string()?;
                    f_3 = Some(val);
                },
                4 => {
                    let val = i_prot.read_i64()?;
                    f_4 = Some(val);
                },
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                },
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("EntComment.author_id", &f_1)?;
        verify_required_field_exists("EntComment.post_id", &f_2)?;
        verify_required_field_exists("EntComment.content", &f_3)?;
        verify_required_field_exists("EntComment.created_time", &f_4)?;
        let ret = EntComment {
            author_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
            post_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
            content: f_3.expect("auto-generated code should have checked for presence of required fields"),
            created_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }

    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("EntComment");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("author_id", TType::I64, 1))?;
        o_prot.write_i64(self.author_id)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("post_id", TType::I64, 2))?;
        o_prot.write_i64(self.post_id)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
        o_prot.write_string(&self.content)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 4))?;
        o_prot.write_i64(self.created_time)?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

impl EntComment {
    /// Validate entity fields according to schema constraints
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

impl EntComment {
    /// Get EntUser entities via author edge
    pub async fn get_author(tao: &TaoInterface, entity_id: i64) -> Result<Option<(i64, crate::generated::EntUser)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntUser>(entity_id, crate::models::AssociationType::PostAuthor, "ent_user", Some(1)).await?;
        Ok(entities.into_iter().next())
    }

    /// Get EntPost entities via post edge
    pub async fn get_post(tao: &TaoInterface, entity_id: i64) -> Result<Option<(i64, crate::generated::EntPost)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntPost>(entity_id, crate::models::AssociationType::CommentParent, "ent_post", Some(1)).await?;
        Ok(entities.into_iter().next())
    }

}

impl Entity for EntComment {
    fn entity_type() -> EntityType {
        EntityType::EntComment
    }
}

impl TaoEntity for EntComment {}


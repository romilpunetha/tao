// Generated by Ent Code Generator - DO NOT EDIT
use serde::{Deserialize, Serialize};
use thrift::protocol::{TInputProtocol, TOutputProtocol, TSerializable, TFieldIdentifier, TStructIdentifier, TType};
use thrift::protocol::{field_id, verify_required_field_exists};
use crate::{
    entities::{Entity, TaoEntity},
    models::EntityType,
    tao_interface::TaoInterface,
    error::AppResult,
};
use anyhow::Result;

#[derive(Debug, Clone, Serialize, Deserialize, Eq, Hash, PartialEq)]
pub struct EntPost {
    pub author_id: i64,
    pub content: String,
    pub media_url: Option<String>,
    pub created_time: i64,
    pub updated_time: Option<i64>,
    pub post_type: String,
    pub visibility: Option<String>,
    pub like_count: i32,
    pub comment_count: i32,
    pub share_count: i32,
    pub tags: Option<serde_json::Value>,
    pub mentions: Option<serde_json::Value>,
}

impl EntPost {
    pub fn new(
        author_id: i64,
        content: String,
        created_time: i64,
        post_type: String,
        like_count: i32,
        comment_count: i32,
        share_count: i32,
    ) -> EntPost {
        EntPost {
            author_id,
            content,
            created_time,
            post_type,
            like_count,
            comment_count,
            share_count,
            media_url: None,
            updated_time: None,
            visibility: Some("public".to_string()),
            tags: None,
            mentions: None,
        }
    }
    
    pub fn with_media_url(mut self, media_url: String) -> Self {
        self.media_url = Some(media_url);
        self
    }
    
    pub fn with_updated_time(mut self, updated_time: i64) -> Self {
        self.updated_time = Some(updated_time);
        self
    }
    
    pub fn with_visibility(mut self, visibility: String) -> Self {
        self.visibility = Some(visibility);
        self
    }
    
    pub fn with_tags(mut self, tags: serde_json::Value) -> Self {
        self.tags = Some(tags);
        self
    }
    
    pub fn with_mentions(mut self, mentions: serde_json::Value) -> Self {
        self.mentions = Some(mentions);
        self
    }
}

impl TSerializable for EntPost {
    fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Self> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<i64> = None;
        let mut f_2: Option<String> = None;
        let mut f_3: Option<String> = None;
        let mut f_4: Option<i64> = None;
        let mut f_5: Option<i64> = None;
        let mut f_6: Option<String> = None;
        let mut f_7: Option<String> = None;
        let mut f_8: Option<i32> = None;
        let mut f_9: Option<i32> = None;
        let mut f_10: Option<i32> = None;
        let mut f_11: Option<String> = None;
        let mut f_12: Option<String> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = i_prot.read_i64()?;
                    f_1 = Some(val);
                },
                2 => {
                    let val = i_prot.read_string()?;
                    f_2 = Some(val);
                },
                3 => {
                    let val = i_prot.read_string()?;
                    f_3 = Some(val);
                },
                4 => {
                    let val = i_prot.read_i64()?;
                    f_4 = Some(val);
                },
                5 => {
                    let val = i_prot.read_i64()?;
                    f_5 = Some(val);
                },
                6 => {
                    let val = i_prot.read_string()?;
                    f_6 = Some(val);
                },
                7 => {
                    let val = i_prot.read_string()?;
                    f_7 = Some(val);
                },
                8 => {
                    let val = i_prot.read_i32()?;
                    f_8 = Some(val);
                },
                9 => {
                    let val = i_prot.read_i32()?;
                    f_9 = Some(val);
                },
                10 => {
                    let val = i_prot.read_i32()?;
                    f_10 = Some(val);
                },
                11 => {
                    let val = i_prot.read_string()?;
                    f_11 = Some(val);
                },
                12 => {
                    let val = i_prot.read_string()?;
                    f_12 = Some(val);
                },
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                },
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("EntPost.author_id", &f_1)?;
        verify_required_field_exists("EntPost.content", &f_2)?;
        verify_required_field_exists("EntPost.created_time", &f_4)?;
        verify_required_field_exists("EntPost.post_type", &f_6)?;
        verify_required_field_exists("EntPost.like_count", &f_8)?;
        verify_required_field_exists("EntPost.comment_count", &f_9)?;
        verify_required_field_exists("EntPost.share_count", &f_10)?;
        let ret = EntPost {
            author_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
            content: f_2.expect("auto-generated code should have checked for presence of required fields"),
            media_url: f_3,
            created_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
            updated_time: f_5,
            post_type: f_6.expect("auto-generated code should have checked for presence of required fields"),
            visibility: f_7,
            like_count: f_8.expect("auto-generated code should have checked for presence of required fields"),
            comment_count: f_9.expect("auto-generated code should have checked for presence of required fields"),
            share_count: f_10.expect("auto-generated code should have checked for presence of required fields"),
            tags: f_11.and_then(|s| serde_json::from_str(&s).ok()),
            mentions: f_12.and_then(|s| serde_json::from_str(&s).ok()),
        };
        Ok(ret)
    }

    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("EntPost");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("author_id", TType::I64, 1))?;
        o_prot.write_i64(self.author_id)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 2))?;
        o_prot.write_string(&self.content)?;
        o_prot.write_field_end()?;
        if let Some(ref fld_var) = self.media_url {
            o_prot.write_field_begin(&TFieldIdentifier::new("media_url", TType::String, 3))?;
            o_prot.write_string(fld_var)?;
            o_prot.write_field_end()?;
        }
        o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 4))?;
        o_prot.write_i64(self.created_time)?;
        o_prot.write_field_end()?;
        if let Some(ref fld_var) = self.updated_time {
            o_prot.write_field_begin(&TFieldIdentifier::new("updated_time", TType::I64, 5))?;
            o_prot.write_i64(*fld_var)?;
            o_prot.write_field_end()?;
        }
        o_prot.write_field_begin(&TFieldIdentifier::new("post_type", TType::String, 6))?;
        o_prot.write_string(&self.post_type)?;
        o_prot.write_field_end()?;
        if let Some(ref fld_var) = self.visibility {
            o_prot.write_field_begin(&TFieldIdentifier::new("visibility", TType::String, 7))?;
            o_prot.write_string(fld_var)?;
            o_prot.write_field_end()?;
        }
        o_prot.write_field_begin(&TFieldIdentifier::new("like_count", TType::I32, 8))?;
        o_prot.write_i32(self.like_count)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("comment_count", TType::I32, 9))?;
        o_prot.write_i32(self.comment_count)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("share_count", TType::I32, 10))?;
        o_prot.write_i32(self.share_count)?;
        o_prot.write_field_end()?;
        if let Some(ref fld_var) = self.tags {
            o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::String, 11))?;
            let json_str = serde_json::to_string(fld_var).unwrap_or_default();
            o_prot.write_string(&json_str)?;
            o_prot.write_field_end()?;
        }
        if let Some(ref fld_var) = self.mentions {
            o_prot.write_field_begin(&TFieldIdentifier::new("mentions", TType::String, 12))?;
            let json_str = serde_json::to_string(fld_var).unwrap_or_default();
            o_prot.write_string(&json_str)?;
            o_prot.write_field_end()?;
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

impl EntPost {
    /// Validate entity fields according to schema constraints
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        if self.content.len() < 1 {
            errors.push(format!("content must be at least 1 characters"));
        }
        if self.content.len() > 10000 {
            errors.push(format!("content must be at most 10000 characters"));
        }
        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

impl EntPost {
    /// Get EntUser entities via author edge
    pub async fn get_author(tao: &TaoInterface, entity_id: i64) -> Result<Option<(i64, crate::generated::EntUser)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntUser>(entity_id, crate::models::AssociationType::PostAuthor, "ent_user", Some(1)).await?;
        entities.into_iter().next().ok_or_else(|| anyhow::anyhow!("Required relationship not found"))
    }

    /// Get EntComment entities via comments edge
    pub async fn get_comments(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntComment)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntComment>(entity_id, crate::models::AssociationType::COMMENTS, "ent_comment", None).await?;
        Ok(entities)
    }

    /// Get EntUser entities via liked_by edge
    pub async fn get_liked_by(tao: &TaoInterface, entity_id: i64) -> Result<Option<(i64, crate::generated::EntUser)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntUser>(entity_id, crate::models::AssociationType::LIKED_BY, "ent_user", Some(1)).await?;
        Ok(entities.into_iter().next())
    }

    /// Get EntUser entities via mentioned_users edge
    pub async fn get_mentioned_users(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntUser)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntUser>(entity_id, crate::models::AssociationType::MENTIONED_USERS, "ent_user", None).await?;
        Ok(entities)
    }

    /// Get EntPage entities via appears_on_pages edge
    pub async fn get_appears_on_pages(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntPage)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntPage>(entity_id, crate::models::AssociationType::APPEARS_ON_PAGES, "ent_page", None).await?;
        Ok(entities)
    }

    /// Get EntGroup entities via shared_in_groups edge
    pub async fn get_shared_in_groups(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntGroup)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntGroup>(entity_id, crate::models::AssociationType::SHARED_IN_GROUPS, "ent_group", None).await?;
        Ok(entities)
    }

    /// Get EntEvent entities via related_events edge
    pub async fn get_related_events(tao: &TaoInterface, entity_id: i64) -> Result<Vec<(i64, crate::generated::EntEvent)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntEvent>(entity_id, crate::models::AssociationType::RELATED_EVENTS, "ent_event", None).await?;
        Ok(entities)
    }

}

impl Entity for EntPost {
    fn entity_type() -> EntityType {
        EntityType::EntPost
    }
}

impl TaoEntity for EntPost {}


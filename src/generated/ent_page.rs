// Generated by Ent Code Generator - DO NOT EDIT
use serde::{Deserialize, Serialize};
use thrift::protocol::{TInputProtocol, TOutputProtocol, TSerializable, TFieldIdentifier, TStructIdentifier, TType};
use thrift::protocol::{field_id, verify_required_field_exists};
use crate::{
    entities::{Entity, TaoEntity},
    models::EntityType,
    tao_interface::TaoInterface,
    error::AppResult,
};
use anyhow::Result;

#[derive(Debug, Clone, Serialize, Deserialize, Eq, Hash, PartialEq)]
pub struct EntPage {
    pub name: String,
    pub description: Option<String>,
    pub created_time: i64,
}

impl EntPage {
    pub fn new(
        name: String,
        created_time: i64,
    ) -> EntPage {
        EntPage {
            name,
            created_time,
            description: None,
        }
    }
    
    pub fn with_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
}

impl TSerializable for EntPage {
    fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Self> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<String> = None;
        let mut f_2: Option<String> = None;
        let mut f_3: Option<i64> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = i_prot.read_string()?;
                    f_1 = Some(val);
                },
                2 => {
                    let val = i_prot.read_string()?;
                    f_2 = Some(val);
                },
                3 => {
                    let val = i_prot.read_i64()?;
                    f_3 = Some(val);
                },
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                },
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("EntPage.name", &f_1)?;
        verify_required_field_exists("EntPage.created_time", &f_3)?;
        let ret = EntPage {
            name: f_1.expect("auto-generated code should have checked for presence of required fields"),
            description: f_2,
            created_time: f_3.expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }

    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("EntPage");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
        o_prot.write_string(&self.name)?;
        o_prot.write_field_end()?;
        if let Some(ref fld_var) = self.description {
            o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 2))?;
            o_prot.write_string(fld_var)?;
            o_prot.write_field_end()?;
        }
        o_prot.write_field_begin(&TFieldIdentifier::new("created_time", TType::I64, 3))?;
        o_prot.write_i64(self.created_time)?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

impl EntPage {
    /// Validate entity fields according to schema constraints
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

impl EntPage {
    /// Get EntUser entities via followers edge
    pub async fn get_followers(tao: &TaoInterface, entity_id: i64) -> Result<Option<(i64, crate::generated::EntUser)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntUser>(entity_id, crate::models::AssociationType::FollowedBy, "ent_user", Some(1)).await?;
        Ok(entities.into_iter().next())
    }

    /// Get EntPost entities via posts edge
    pub async fn get_posts(tao: &TaoInterface, entity_id: i64) -> Result<Option<(i64, crate::generated::EntPost)>> {
        let entities = tao.get_associated_entities::<crate::generated::EntPost>(entity_id, crate::models::AssociationType::PostAuthor, "ent_post", Some(1)).await?;
        Ok(entities.into_iter().next())
    }

}

impl Entity for EntPage {
    fn entity_type() -> EntityType {
        EntityType::EntPage
    }
}

impl TaoEntity for EntPage {}


# TAO Database System - AI Context Documentation

## Project Overview

TAO (The Associations and Objects) is a Rust-based database system inspired by Facebook's TAO, designed for managing social graph data with high performance and type safety. This document provides comprehensive context for AI assistants to understand and maintain the system.

## System Architecture

- To understand system evolution read the docs in `ai_docs\changelog\*.md`

### Architecture Principles
- **Clean Layering**: TAO core should only be used within the ent implementation files
- **Interface-based Design**: TAO should never be exposed publicly other than to Ent framework
- **Dependency Injection**: Eliminate global state in favor of context passing
- **Strong Typing**: Use newtype patterns for type safety (EntityId, EntityType)
- **Single Responsibility**: Each module has a clear, focused purpose

### Core Components

1. **TAO Core** (`src/infrastructure/tao_core.rs`)
   - Main database abstraction layer
   - Handles object storage, associations, and queries
   - Provides connection pooling and caching
   - Multi-shard support with PostgreSQL backends

2. **Entity Framework** (`src/ent_framework/`)
   - Type-safe entity definitions and operations
   - Automatic code generation for entities
   - Builder pattern for entity creation
   - Validation and serialization using Thrift

3. **Code Generation System** (`src/codegen/`)
   - Modular code generator for entities, builders, and implementations
   - Schema-driven generation from JSON definitions
   - Thrift integration for serialization
   - Domain-driven file organization

### Database Layer

- **Backend**: PostgreSQL with multi-shard support
- **Caching**: Multi-level cache system with LRU eviction
- **Serialization**: Apache Thrift for efficient data serialization
- **Connection Management**: Pooled connections with automatic failover

### Entity System

#### Entity Structure
All entities follow this pattern:
```rust
pub struct EntUser {
    pub id: i64,
    pub username: String,
    pub email: String,
    pub created_time: i64,
    // ... other fields
}
```

#### Unified Builder Pattern (Direct Implementation)
EntBuilder is implemented directly on entity types, eliminating separate builder structs:
```rust
// EntBuilder implemented directly on entity
impl EntBuilder for EntUser {
    type BuilderState = UserBuilderState;

    fn build(state: Self::BuilderState, id: i64) -> Result<Self, String> {
        // Build entity with TAO-generated ID using builder state
    }

    fn entity_type() -> &'static str { "ent_user" }
}

// Simple builder state structure (generated by codegen)
pub struct UserBuilderState {
    username: Option<String>,
    email: Option<String>,
    // ... all fields as Option<T>
}

// Fluent interface on builder state
impl UserBuilderState {
    pub fn username(mut self, username: String) -> Self { ... }
    pub async fn savex(self) -> AppResult<EntUser> {
        get_global_tao()?.create_entity::<EntUser>(self).await
    }
}
```

#### Key Methods
- `EntBuilder::build(state, id)` - Implemented on entity, called by TAO after ID generation
- `BuilderState.savex()` - Saves entity to database via TAO's `create_entity::<T>()` method
- `Entity::create()` - Static method returning new builder state instance
- TAO handles the complete flow: ID generation → EntBuilder::build(state, id) → storage

#### Architecture Benefits
- **No Separate Builder Structs**: Eliminates `EntUserBuilder`, `EntPostBuilder`, etc.
- **Direct Implementation**: `EntBuilder` implemented directly on entity types
- **Simplified Codegen**: Only generates builder state structs and trait implementations
- **Cleaner API**: `EntUser::create().username().email().savex()` flows naturally

## Current State

### Generated Entities
The system currently has 6 entity types:
1. **EntUser** - User profiles with authentication data
2. **EntPost** - Social media posts with content and metadata
3. **EntComment** - Comments on posts
4. **EntGroup** - Social groups/communities
5. **EntPage** - Pages/organizations
6. **EntEvent** - Events and activities

### Proposed Improved File Organization
```
src/
├── core/                   # Core abstractions and types
│   ├── types.rs           # TaoId, TaoTime, EntityId, EntityType (strong types)
│   ├── traits.rs          # Core traits (DatabaseInterface, CacheInterface)
│   └── error.rs           # Centralized error handling
├── infrastructure/        # Clean infrastructure layer
│   ├── database/          # Database implementations
│   │   ├── postgres.rs    # PostgreSQL implementation
│   │   └── mod.rs         # Database abstractions
│   ├── cache/             # Caching implementations
│   │   ├── memory.rs      # In-memory cache
│   │   ├── redis.rs       # Redis cache
│   │   └── mod.rs         # Cache abstractions
│   ├── storage/           # Storage backends
│   └── tao_core.rs        # Main TAO operations
├── framework/             # Entity framework (renamed from ent_framework)
│   ├── entity/            # Entity trait and implementations
│   ├── builder/           # Unified builder trait (EntBuilder only)
│   ├── schema/            # Schema definitions
│   └── codegen/           # Code generation (moved from root)
├── domains/               # Generated entity domains
│   └── [user|post|comment|group|page|event]/
└── applications/          # Application layer
    ├── web_server.rs      # REST API server
    └── cli/               # CLI tools
```

### Current File Organization
```
src/
├── core/                   # Core abstractions and types
│   ├── types.rs           # TaoId, TaoTime, EntityId, EntityType (strong types)
│   ├── traits.rs          # Core traits (DatabaseInterface, CacheInterface)
│   └── error.rs           # Centralized error handling
├── infrastructure/        # Clean infrastructure layer
│   ├── database/          # Database implementations
│   │   ├── postgres.rs    # PostgreSQL implementation
│   │   └── mod.rs         # Database abstractions
│   ├── cache/             # Caching implementations
│   │   ├── memory.rs      # In-memory cache
│   │   ├── redis.rs       # Redis cache
│   │   └── mod.rs         # Cache abstractions
│   ├── storage/           # Storage backends
│   └── tao_core/          # Main TAO operations
├── framework/             # Entity framework (renamed from ent_framework)
│   ├── entity/            # Entity trait and implementations
│   ├── builder/           # Unified builder trait (EntBuilder only)
│   ├── schema/            # Schema definitions
│   └── codegen/           # Code generation (moved from root)
├── domains/               # Generated entity domains
│   └── [user|post|comment|group|page|event]/
└── applications/          # Application layer
    ├── web_server.rs      # REST API server
    └── cli/               # CLI tools
```

## Key Design Principles

### Type Safety (Enhanced)
- **Strong Typing**: Use newtype patterns (EntityId, EntityType, AssociationType) instead of primitive aliases
- **Unified Builder Pattern**: Single EntBuilder trait eliminates duplication and ensures consistency
- **Compile-time Verification**: Entity types and field requirements validated at compile time
- **Interface-based Design**: Abstract traits for testability and modularity

### Performance
- Multi-level caching with automatic invalidation
- Connection pooling for database efficiency
- Batch operations for loading multiple entities
- Efficient serialization with Thrift

### Code Generation
- Schema-driven development with JSON entity definitions
- Automatic generation of boilerplate code
- Consistent patterns across all entities
- Regeneration preserves manual customizations in designated areas

#### Code Generation Principles for Entities
- Always edit generated code through the code generator, not manually
- If the code is generated by codegen, it'll have the string `// Generated by TAO Ent Framework` and if it is generated by thrift it'll have the string `// Autogenerated by Thrift Compiler`. Do not edit such files directly.
- Before generating the code using codegen, remove all the existing generated code from the domain folder and clear `mod.rs` so that we don't have compilation errors. Then generate the code using the codegen and then add the generated entities to the `mod.rs` file.

### Database Design
- Object-centric storage with TAO principles
- Association management for relationships
- Sharding support for horizontal scaling
- ACID compliance with PostgreSQL

## API Endpoints

The web server (`tao_web_server.rs`) provides REST endpoints:
- `POST /api/users` - Create new user
- `GET /api/users/{id}` - Get user by ID
- `GET /api/users` - List all users
- `POST /api/seed` - Seed database with sample data
- Health check endpoints

## Development Workflow

### Adding New Entities
1. Define entity schema in `schemas/` directory
2. Run `cargo run --bin codegen` to generate code
3. Implement custom business logic in `ent_impl.rs` files
4. Add API endpoints in web server if needed

### Builder Usage Patterns
```rust
// Create entity without saving (for testing/validation)
let user = EntUser::create()
    .username("john_doe".to_string())
    .email("john@example.com".to_string())
    .build(123)?;

// Create and save entity to database
let user = EntUser::create()
    .username("john_doe".to_string())
    .email("john@example.com".to_string())
    .savex().await?;
```

### Recent Updates
- Added `build()` method to builders for creating entities without database interaction
- Enhanced builder pattern with ID field support
- Implemented `EntBuilder` trait for consistent builder interface
- Improved code generation with trait implementations

## Testing and Validation

### Entity Validation
- All entities implement `validate()` method
- Field-level validation with custom rules
- Required field checking in builders
- Type-safe field access patterns

### Database Testing
- Multi-shard configuration for testing
- Sample data seeding functionality
- Health check endpoints for monitoring
- Error handling with structured error types

## Configuration

### Database Configuration
- PostgreSQL connection strings for multiple shards
- Connection pool settings
- Cache configuration parameters
- Logging and monitoring setup

### Environment Variables
- Database URLs for different environments
- Cache size and eviction policies
- Web server port and host configuration

## Troubleshooting Guide

### Common Issues
1. **Missing ID field in builders**: Run `cargo run --bin codegen` to regenerate
2. **Compilation errors after schema changes**: Clean and rebuild project
3. **Database connection failures**: Check PostgreSQL service and connection strings
4. **Cache inconsistencies**: Clear cache or restart service

### Debugging Tips
- Enable debug logging for TAO operations
- Use `cargo check` for quick compilation validation
- Monitor database connections and query performance
- Check Thrift serialization for data integrity

## AI Assistant Guidelines

### When Working on This Project
1. **Always preserve existing patterns**: Follow established conventions for entities, builders, and traits
2. **Use code generation**: Don't manually create entity files; use the codegen system
3. **Maintain type safety**: Ensure all changes preserve compile-time guarantees
4. **Test thoroughly**: Verify both builder patterns (`build()` and `savex()`) work correctly
5. **Update documentation**: Keep this file current with any architectural changes

### Code Modification Principles
- When adding new functionality, follow the existing trait-based patterns
- If there is a major change to the system that requires not adhering to backward compatibility, ask first. During initial development phase we don't care about backward compatibility and can tear down the system and rebuild from scratch so it is ok to delete stuff and replace it. This is true for DB schema also. In the initial phase of development it is ok to delete the database and recreate.
- Ensure all database operations are properly error-handled
- For every code change log the planned changes using `ai_docs\templates\task_template.md` and follow the instructions there to generate a changelog before making the changes and put the status of the task as `PENDING`. Once you've completed the task, update the created task with status `COMPLETED`. Also update the GEMINI.md and your own memory so that the AI agent has the latest information on the system.
- If you were interrupted, use `ai_docs\templates\task_template.md` to view your last plan and continue that. 

### Performance Considerations
- Consider caching implications for new features
- Use batch operations for multiple entity operations
- Monitor database query patterns and optimize as needed
- Preserve connection pooling and transaction safety

This document should be updated whenever significant architectural changes are made to the system.
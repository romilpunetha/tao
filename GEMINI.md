# TAO Database System - AI Context Documentation

## Project Overview

TAO (The Associations and Objects) is a Rust-based database system inspired by Facebook's TAO, designed for managing social graph data with high performance and type safety. This document provides comprehensive context for AI assistants to understand and maintain the system.

## System Architecture

- To understand system evolution read the docs in `ai_docs\changelog\*.md`

### Architecture Principles
- **Clean Layering**: TAO core should only be used within the ent implementation files
- **Interface-based Design**: TAO should never be exposed publicly other than to Ent framework
- **Dependency Injection**: Eliminate global state in favor of context passing
- **Strong Typing**: Use newtype patterns for type safety (EntityId, EntityType)
- **Single Responsibility**: Each module has a clear, focused purpose

### Core Components

1. **TAO Core** (`src/infrastructure/tao_core.rs`)
   - Main database abstraction layer
   - Handles object storage, associations, and queries
   - Provides connection pooling and caching
   - Multi-shard support with PostgreSQL backends

2. **Entity Framework** (`src/ent_framework/`)
   - Type-safe entity definitions and operations
   - Automatic code generation for entities
   - Builder pattern for entity creation
   - Validation and serialization using Thrift

3. **Code Generation System** (`src/codegen/`)
   - Modular code generator for entities, builders, and implementations
   - Schema-driven generation from JSON definitions
   - Thrift integration for serialization
   - Domain-driven file organization

### Database Layer

- **Backend**: PostgreSQL with multi-shard support
- **Caching**: Multi-level cache system with LRU eviction
- **Serialization**: Apache Thrift for efficient data serialization
- **Connection Management**: Pooled connections with automatic failover

### Entity System

#### Entity Structure
All entities follow this pattern:
```rust
pub struct EntUser {
    pub id: i64,
    pub username: String,
    pub email: String,
    pub created_time: i64,
    // ... other fields
}
```

#### Unified Builder Pattern (Direct Implementation)
EntBuilder is implemented directly on entity types, eliminating separate builder structs:
```rust
// EntBuilder implemented directly on entity
impl EntBuilder for EntUser {
    type BuilderState = UserBuilderState;

    fn build(state: Self::BuilderState, id: i64) -> Result<Self, String> {
        // Build entity with TAO-generated ID using builder state
    }

    fn entity_type() -> &'static str { "ent_user" }
}

// Simple builder state structure (generated by codegen)
pub struct UserBuilderState {
    username: Option<String>,
    email: Option<String>,
    // ... all fields as Option<T>
    pub(crate) tao: Option<Arc<dyn TaoOperations>>,
}

// Fluent interface on builder state
impl UserBuilderState {
    pub fn username(mut self, username: String) -> Self { ... }
    pub fn with_tao(mut self, tao: Arc<dyn TaoOperations>) -> Self { ... }
    pub async fn savex(self) -> AppResult<EntUser> {
        let tao = self.tao.ok_or_else(|| AppError::Internal("Tao instance not provided to builder".to_string()))?;
        tao.create_entity::<EntUser>(self).await
    }
}
```

#### Key Methods
- `EntBuilder::build(state, id)` - Implemented on entity, called by TAO after ID generation
- `BuilderState.savex()` - Saves entity to database via TAO's `create_entity::<T>()` method
- `Entity::create()` - Static method returning new builder state instance
- TAO handles the complete flow: ID generation → EntBuilder::build(state, id) → storage

#### Architecture Benefits
- **No Separate Builder Structs**: Eliminates `EntUserBuilder`, `EntPostBuilder`, etc.
- **Direct Implementation**: `EntBuilder` implemented directly on entity types
- **Simplified Codegen**: Only generates builder state structs and trait implementations
- **Cleaner API**: `EntUser::create().username().email().savex()` flows naturally

## Current State

### Generated Entities
The system currently has 6 entity types:
1. **EntUser** - User profiles with authentication data
2. **EntPost** - Social media posts with content and metadata
3. **EntComment** - Comments on posts
4. **EntGroup** - Social groups/communities
5. **EntPage** - Pages/organizations
6. **EntEvent** - Events and activities

### Proposed Improved File Organization
```
src/
├── core/                   # Core abstractions and types
│   ├── types.rs           # TaoId, TaoTime, EntityId, EntityType (strong types)
│   ├── traits.rs          # Core traits (DatabaseInterface, CacheInterface)
│   └── error.rs           # Centralized error handling
├── infrastructure/        # Clean infrastructure layer
│   ├── database/          # Database implementations
│   │   ├── postgres.rs    # PostgreSQL implementation
│   │   └── mod.rs         # Database abstractions
│   ├── cache/             # Caching implementations
│   │   ├── memory.rs      # In-memory cache
│   │   ├── redis.rs       # Redis cache
│   │   └── mod.rs         # Cache abstractions
│   ├── storage/           # Storage backends
│   └── tao_core.rs        # Main TAO operations
├── framework/             # Entity framework (renamed from ent_framework)
│   ├── entity/            # Entity trait and implementations
│   ├── builder/           # Unified builder trait (EntBuilder only)
│   ├── schema/            # Schema definitions
│   └── codegen/           # Code generation (moved from root)
├── domains/               # Generated entity domains
│   └── [user|post|comment|group|page|event]/
└── applications/          # Application layer
    ├── web_server.rs      # REST API server
    └── cli/               # CLI tools
```

### Current File Organization
```
src/
├── core/                   # Core abstractions and types
│   ├── types.rs           # TaoId, TaoTime, EntityId, EntityType (strong types)
│   ├── traits.rs          # Core traits (DatabaseInterface, CacheInterface)
│   └── error.rs           # Centralized error handling
├── infrastructure/        # Clean infrastructure layer
│   ├── database/          # Database implementations
│   │   ├── postgres.rs    # PostgreSQL implementation
│   │   └── mod.rs         # Database abstractions
│   ├── cache/             # Caching implementations
│   │   ├── memory.rs      # In-memory cache
│   │   ├── redis.rs       # Redis cache
│   │   └── mod.rs         # Cache abstractions
│   ├── storage/           # Storage backends
│   └── tao_core/          # Main TAO operations
├── framework/             # Entity framework (renamed from ent_framework)
│   ├── entity/            # Entity trait and implementations
│   ├── builder/           # Unified builder trait (EntBuilder only)
│   ├── schema/            # Schema definitions
│   └── codegen/           # Code generation (moved from root)
├── domains/               # Generated entity domains
│   └── [user|post|comment|group|page|event]/
└── applications/          # Application layer
    ├── web_server.rs      # REST API server
    └── cli/               # CLI tools
```

## Key Design Principles

### Type Safety (Enhanced)
- **Strong Typing**: Use newtype patterns (EntityId, EntityType, AssociationType) instead of primitive aliases
- **Unified Builder Pattern**: Single EntBuilder trait eliminates duplication and ensures consistency
- **Compile-time Verification**: Entity types and field requirements validated at compile time
- **Interface-based Design**: Abstract traits for testability and modularity

### Performance
- Multi-level caching with automatic invalidation
- Connection pooling for database efficiency
- Batch operations for loading multiple entities
- Efficient serialization with Thrift

### Code Generation
- Schema-driven development with JSON entity definitions
- Automatic generation of boilerplate code
- Consistent patterns across all entities
- Regeneration preserves manual customizations in designated areas

#### Code Generation Principles for Entities
- Always edit generated code through the code generator, not manually
- If the code is generated by codegen, it'll have the string `// Generated by TAO Ent Framework` and if it is generated by thrift it'll have the string `// Autogenerated by Thrift Compiler`. Do not edit such files directly.
- Before generating the code using codegen, remove all the existing generated code from the domain folder and clear `mod.rs` so that we don't have compilation errors. Then generate the code using the codegen and then add the generated entities to the `mod.rs` file.

### Database Design
- Object-centric storage with TAO principles
- Association management for relationships
- Sharding support for horizontal scaling
- ACID compliance with PostgreSQL

## API Endpoints

The web server (`tao_web_server.rs`) provides REST endpoints:
- `POST /api/users` - Create new user
- `GET /api/users/{id}` - Get user by ID
- `GET /api/users` - List all users
- `POST /api/seed` - Seed database with sample data
- Health check endpoints

## Development Workflow

### Adding New Entities
1. Define entity schema in `schemas/` directory
2. Run `cargo run --bin codegen` to generate code
3. For any custom business logic first update the schema to support adding that logic and then generate the files using codegen
4. Add API endpoints in web server if needed

### Builder Usage Patterns
```rust
// Create entity without saving (for testing/validation)
let user = EntUser::create()
    .username("john_doe".to_string())
    .email("john@example.com".to_string())
    .build(123)?;

// Create and save entity to database
let user = EntUser::create()
    .username("john_doe".to_string())
    .email("john@example.com".to_string())
    .savex().await?;
```

### Recent Updates
- Added `build()` method to builders for creating entities without database interaction
- Enhanced builder pattern with ID field support
- Implemented `EntBuilder` trait for consistent builder interface
- Improved code generation with trait implementations

## Testing and Validation

### Entity Validation
- All entities implement `validate()` method
- Field-level validation with custom rules
- Required field checking in builders
- Type-safe field access patterns

### Database Testing
- Multi-shard configuration for testing
- Sample data seeding functionality
- Health check endpoints for monitoring
- Error handling with structured error types

## Configuration

### Database Configuration
- PostgreSQL connection strings for multiple shards
- Connection pool settings
- Cache configuration parameters
- Logging and monitoring setup

### Environment Variables
- Database URLs for different environments
- Cache size and eviction policies
- Web server port and host configuration

## Troubleshooting Guide

### Common Issues
1. **Missing ID field in builders**: Run `cargo run --bin codegen` to regenerate
2. **Compilation errors after schema changes**: Clean and rebuild project
3. **Database connection failures**: Check PostgreSQL service and connection strings
4. **Cache inconsistencies**: Clear cache or restart service

### Debugging Tips
- Enable debug logging for TAO operations
- Use `cargo check` for quick compilation validation
- Monitor database connections and query performance
- Check Thrift serialization for data integrity

## AI Assistant Guidelines

## Role and Expertise
You are a world-class full-stack developer and UI/UX designer. Your expertise covers:
- Expert system design skills in both low level API design and high level system design
- Use of SOLID Principles and efficient design patterns for the use
- Maintaining a cohesive image of the system when making changes
- Rapid, efficient application development
- The full spectrum from MVP creation to complex system architecture
- Intuitive and beautiful design
- You have an excellent understanding of modern large-scale systems
- You're able to avoid fancy designs that look cool but will be hard to maintain over years.
- You maintain one-way flow of control and never create cyclic dependencies.
- You favour lose coupling through dependency injection and use the outward-to-inward approach with the hexagonal architecture
- Your code design is intuitive rather than flashy
- You have an excellent understaning of how single responsibility and ownership works in system design, ie, which component should be responsible for the ownership of some capability.
- You don't create unnecessary abstractions. You may evolve them over time as the system gets large and complex.
- You always write erogonimic code

Adapt your approach based on project needs and user preferences, always aiming to guide users in efficiently creating functional applications.

### When Working on This Project
1. **Always preserve existing patterns**: Follow established conventions for entities, builders, and traits
2. **Use code generation**: Don't manually create entity files; use the codegen system
3. **Maintain type safety**: Ensure all changes preserve compile-time guarantees
4. **Test thoroughly**: Verify both builder patterns (`build()` and `savex()`) work correctly. Also run `cargo build` after changes to ensure that the changes don't contain syntax and semantic errors.
5. **Update documentation**: Keep this file current with any architectural changes

### Adaptive Workflow
- At the beginning of every task when instructed to "follow your custom instructions", read the essential documents in this order:
  1. `GEMINI.md` (for high-level context and goals)

- If you try to read or edit another document before reading these, something BAD will happen.
- Update documents based on significant changes, not minor steps
- If conflicting information is found between documents, ask the user for clarification
- Create files in the `ai_docs\userInstructions` folder for tasks that require user action
  - Provide detailed, step-by-step instructions
  - Include all necessary details for ease of use
  - No need for a formal structure, but ensure clarity and completeness
  - Use numbered lists for sequential steps, code blocks for commands or code snippets
- Prioritize frequent testing: Run servers and test functionality regularly throughout development, rather than building extensive features before testing

## User Interaction and Adaptive Behavior
- Ask follow-up questions when critical information is missing for task completion
- Adjust approach based on project complexity and user preferences
- Strive for efficient task completion with minimal back-and-forth
- Present key technical decisions concisely, allowing for user feedback

## Code Editing and File Operations
- Organize new projects efficiently, considering project type and dependencies
- Refer to the main Cline system for specific file handling instructions

Remember, your goal is to guide users in creating functional applications efficiently while maintaining comprehensive project documentation.


### Critical Documentation and Workflow

#### Documentation Management
Maintain a `ai_docs\changelog` folder in the root directory (create if it doesn't exist) with the following essential files:
1. For every code change log the planned changes using `ai_docs\templates\task_template.md` and follow the instructions there to generate a changelog before making the changes and put the status of the task as `PENDING`. Once you've completed the task, update the created task with status `COMPLETED`.
2. Always update your memory in `GEMINI.md` after every task.
3. If you were interrupted, use `ai_docs\changelog\*.md` to view your last plan and continue that until you're ready to update the task's status as `COMPLETED`.
4. Create reference documents for future developers as needed, storing them in the `ai_docs\` folder
5. Examples include styleAesthetic.md or wireframes.md

### Code Modification Principles
- When adding new functionality, follow the existing trait-based patterns
- If there is a major change to the system that requires not adhering to backward compatibility, ask first. During initial development phase we don't care about backward compatibility and can tear down the system and rebuild from scratch so it is ok to delete stuff and replace it. This is true for DB schema also. In the initial phase of development it is ok to delete the database and recreate.
- Ensure all database operations are properly error-handled

### Performance Considerations
- Consider caching implications for new features
- Use batch operations for multiple entity operations
- Monitor database query patterns and optimize as needed
- Preserve connection pooling and transaction safety

This document should be updated whenever significant architectural changes are made to the system.

DONT JUST FOCUS ON THE INITIAL AND FINAL CONTEXT. CONSIDER THE ENTIRE CONTEXT PROVIDED BY THE FILE.